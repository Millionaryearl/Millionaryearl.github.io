<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chen&#39;s Alchemy</title>
  <subtitle>iOS Notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://millionaryearl.github.io/"/>
  <updated>2016-10-09T08:29:00.000Z</updated>
  <id>https://millionaryearl.github.io/</id>
  
  <author>
    <name>Chen Wei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Crawl Web Content - 粗解爬虫解析流程及结果输出</title>
    <link href="https://millionaryearl.github.io/2016/10/09/python-Scrapy-parser/"/>
    <id>https://millionaryearl.github.io/2016/10/09/python-Scrapy-parser/</id>
    <published>2016-10-09T08:29:15.000Z</published>
    <updated>2016-10-09T08:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过上一篇博客的工作，我们拥有了一个简单爬虫。但确实有点简陋的过分了，要啥啥没有，所以今天主要就是简单讲解一下爬虫的解析流程与爬取结果的输出形式。<br><strong><em>新任务获得：粗解爬虫解析流程并设置爬取结果的输出</em></strong></p>
<a id="more"></a>
<h2 id="抓取流程"><a href="#抓取流程" class="headerlink" title="抓取流程"></a>抓取流程</h2><p><img src="https://cl.ly/3h3F0j1d1P0s/python_2_1.png" alt=""><br>实际上爬虫的工作流程很是直白的。首先找到包含目标信息的网站的网址，写入爬虫文件的<code>start_urls</code>参数，做为爬取的起始点。同时输入适当的网址到<code>allowed_domains</code>参数，来约束爬取的范围。</p>
<p>第二步是爬取到网站内容，这个内容基本上会以<code>HTML&amp;CSS</code>格式呈现，这一步<code>scrapy</code>会帮我们做的，通常我们只需要运行爬虫就可以了，应对一个复杂要求(例如：应对网站反爬取设置)可以在<code>/settings.py</code>文件里配置爬虫参数。感兴趣的可以<a href="https://doc.scrapy.org/en/latest/topics/settings.html" target="_blank" rel="external">正面上我</a></p>
<p>第三步是过滤抓取内容，以获得我们需要的信息。这个要求我们在运行爬虫之前制定好过滤规则，然后在运行爬虫时<code>scrapy</code>会直接使用</p>
<p>最后一步就是输出了，无论是直接以log形式在命令行里输出，还是保存到文件里，亦或是直接输入数据库都可以.</p>
<p>至此我们今天的任务就明确了，主要是讲解下在第三步和第四步要怎么做。<br><strong><em>任务更新：合理制定爬虫过滤规则与爬虫输出设置</em></strong></p>
<h2 id="制定爬虫过滤规则"><a href="#制定爬虫过滤规则" class="headerlink" title="制定爬虫过滤规则"></a>制定爬虫过滤规则</h2><p>因为每个抓取站点的h5文件结构都不一样，所以爬虫的可重用性比较低。对于不同的抓取目标，我们需要制定不同的抓取语句。一般的制定流程是先查阅目标站的H5结构，进而定制对应的抓取结构，最后编写抓取语句。</p>
<h3 id="查阅目标站点H5结构"><a href="#查阅目标站点H5结构" class="headerlink" title="查阅目标站点H5结构"></a>查阅目标站点H5结构</h3><ol>
<li><p>在命令行里查看<br> 使用<code>Scrapy</code>的<code>fetch</code>函数就可以直接现实H5文件结构</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy fetch http://www.biquge.tw/0_972/</div></pre></td></tr></table></figure>
</li>
<li><p>在浏览器里查看<br>这个么更直接，在浏览器里打开目标地址，然后进入开发者模式，显示网页源文件就可以看到了</p>
</li>
</ol>
<h3 id="定制抓取机制"><a href="#定制抓取机制" class="headerlink" title="定制抓取机制"></a>定制抓取机制</h3><p>这个么需要一定的H5和CSS基本知识，一点都不懂的可以去<a href="http://www.w3school.com.cn" target="_blank" rel="external">W3CSchool</a>上了解一下。例如我的目标信息是：小说章节的名称与链接地址。在刚才得到的H5结构文件里，查找对应的数据单元：</p>
<pre><code>&lt;dd&gt; &lt;a style=&quot;&quot; href=&quot;/0_972/4743476.html&quot;&gt;第一千五百九十五章 黑暗现象&lt;/a&gt;&lt;/dd&gt;
</code></pre><p>可以看到我们需要的信息是存在于<code>&lt;dd&gt;&lt;/dd&gt;</code>标签内的一个<code>&lt;a&gt;</code>标签里的。所以我们需要的抓取机制应该是：</p>
<ul>
<li><strong>先筛选出所有的<code>&lt;dd&gt;&lt;/dd&gt;</code>标签</strong></li>
<li><strong>然后抓取之中的<code>&lt;a&gt;</code>标签下的<code>title</code>和<code>href</code>两个属性下的数据</strong></li>
</ul>
<p>那有人可能就会问了，明明我们需要的目标信息的最小标签单元是<code>&lt;a&gt;</code>标签,为什么要多此一举的先去筛选出上一级的<code>&lt;dd&gt;&lt;/dd&gt;</code>标签？那是因为网页里有很多其他的<code>&lt;a&gt;</code>标签，但它们的信息并非小说的章节信息，为了过滤掉这些合规却又不是有效信息的<code>&lt;a&gt;</code>标签内容，我们需要加入额外的筛选条件－上一级的<code>&lt;dd&gt;&lt;/dd&gt;</code>标签。</p>
<pre><code>&lt;li&gt;&lt;a href=&quot;/nweph.html&quot;&gt;排行榜单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/quanben/&quot;&gt;完本小说&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow&quot; href=&quot;/jilu.php&quot;&gt;阅读记录&lt;/a&gt;&lt;/li&gt;
</code></pre><h3 id="编写抓取语句"><a href="#编写抓取语句" class="headerlink" title="编写抓取语句"></a>编写抓取语句</h3><p>这个抓取语句主要是写在爬虫文件中的”parse”函数里。这里我们打开<code>fiction/spiders/biquge.py</code>文件并编辑如下</p>
<pre><code># -*- coding: utf-8 -*-  
from scrapy.spiders import Spider
from scrapy.selector import Selector
from fiction.items import FictionItem

class BiqugeSpider(Spider):
    name = &quot;biquge&quot;
    allowed_domains = [&quot;http://www.biquge.tw/&quot;]
    start_urls = (
        &apos;http://www.biquge.tw/0_972/&apos;,
    )

    def parse(self, response):
        chapters = response.xpath(&apos;//dd&apos;)
        items = []

        for chapter in chapters:
            item = FictionItem()
            item[&apos;url&apos;] = chapter.xpath(
                &apos;a/@href&apos;).extract()
            item[&apos;title&apos;] = chapter.xpath(
                &apos;a/text()&apos;).extract()
            items.append(item)

            print item[&apos;url&apos;], item[&apos;title&apos;]

        return items
</code></pre><p>上面的代码很好理解，前两行是引入相关的<code>scrapy</code>基础类，第三行是引入我们自定义的数据结构（具体信息可以去上篇博客里查看－定义模型）. 再下来么就是我们爬虫类<code>biqugeSpider</code>，头三行的爬虫属性设置也在上篇说过了，直接看到重点<code>parse</code>函数。</p>
<p>可以看到这个函数接收到了两个外部参数, <code>self</code> 和 <code>response</code>。<code>self</code>应该就是指爬虫自己，具体有啥用处，作者只能表示今天天气不错，啊哈哈哈。而<code>response</code>参数就是上述<code>抓取流程－第二步</code>抓取到全部网站内容，它应该是和上述<code>定制爬虫过滤规则－查阅目标站点H5结构</code>里看到的内容一致。</p>
<p>接下来就如上述<code>定制爬虫过滤规则－定制抓取机制</code>计划的一样，先过滤出所有的<code>&lt;dd&gt;&lt;/dd&gt;</code>标签内容，并建立一个空数组用以将来存储标签对象<code>Fiction</code>。再接下来建立一个<code>for</code>循环，从每段<code>&lt;dd&gt;&lt;/dd&gt;</code>标签内容里，进一步过滤出<code>url</code>和<code>title</code>字段信息，并存入新建的<code>Fiction</code>对象，加入到<code>items</code>结果数组里，同时在命令行里输出<code>url</code>和<code>title</code>结果。 最后在<code>for</code>循环结束后，返回<code>items</code>结果数组(这个暂时没有，稍后我们配置结果输出到json文件时会用到)</p>
<h3 id="数据提取机制"><a href="#数据提取机制" class="headerlink" title="数据提取机制"></a>数据提取机制</h3><p>虽然说知道了这段代码是怎么工作的，但具体怎么写不知道啊，到底怎么样才能从HTML源码中提取数据呢？其实有些库是可以做到的：</p>
<ul>
<li><a href="http://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="external">BeautifulSoup</a> 是在程序员间非常流行的网页分析库，它基于HTML代码的结构来构造一个Python对象， 对不良标记的处理也非常合理，但它有一个缺点：慢。<br>比如这些</li>
<li><a href="http://lxml.de/" target="_blank" rel="external">lxml</a> 是一个基于 <a href="http://docs.python.org/library/xml.etree.elementtree.html" target="_blank" rel="external">ElementTree</a> (不是Python标准库的一部分)的python化的XML解析库(也可以解析HTML)。</li>
</ul>
<p>但伟大的奥斯忒懦夫司机·作者曾经又说过</p>
<blockquote>
<p>作为一个菜鸡程序员，要有菜鸡程序员的尊严，坚决抵制听啊没听过的东西！</p>
</blockquote>
<p>所以有啥简单点的东西呢，找找看官网还真有－<code>Seletors</code>就可以完美替代，它是<code>Scrapy</code>自己提供的数据提取机制，可以通过特定的<code>XPath</code>和<code>CSS</code>表达式来选择 HTML文件中的某个部分。本篇作者就是用的这种提取机制，例如：</p>
<pre><code>response.xpath(&apos;//dd&apos;) //提取网页内容里的所有&lt;dd&gt;&lt;/dd&gt;标签内容
...
chapter.xpath(&apos;a/@href&apos;).extract() //提取chapther中&lt;a&gt;标签的@href属性
chapter.xpath(&apos;a/text()&apos;).extract() //提取chapther中&lt;a&gt;标签的text值
</code></pre><p>更多的<code>Seletor</code>提取讲解，可以<a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/topics/selectors.html#topics-selectors-ref" target="_blank" rel="external">正面上我</a></p>
<h2 id="设置爬虫输出设置"><a href="#设置爬虫输出设置" class="headerlink" title="设置爬虫输出设置"></a>设置爬虫输出设置</h2><p>至此我们的爬虫可以说已经是大功告成，但数据抓是抓到了，怎么输出来用呢。大概是有三个方向：</p>
<h3 id="直接以log形式在命令行里输出"><a href="#直接以log形式在命令行里输出" class="headerlink" title="直接以log形式在命令行里输出"></a>直接以log形式在命令行里输出</h3><p>这个最简单了，只要在爬虫文件里的<code>parse</code>函数里，使用<code>print</code>命令把相应的信息给打出来就可以了</p>
<pre><code>print item[&apos;url&apos;], item[&apos;title&apos;]
</code></pre><h3 id="保存到文件里"><a href="#保存到文件里" class="headerlink" title="保存到文件里"></a>保存到文件里</h3><p>半自动的呢，可以在启动爬虫时，加入输出参数 <code>-o outputFileName</code>。需要注意的是<code>Scrapy</code>默认支持四种格式:<code>JSON</code>, <code>JSON lines</code>, <code>CSV</code>, <code>XML</code></p>
<pre><code>scrapy crawl fiction -o result.json 
// scrapy crawl spiderName -0 outputFileName
</code></pre><p>正规一点的呢，需要修改<code>/pipelines.py</code>文件如下：</p>
<pre><code>import json  
import codecs  
import re

class FictionPipeline(object):

def __init__(self):  
    self.file = codecs.open(&apos;cn_zhan.json&apos;, &apos;wb&apos;, encoding=&apos;utf-8&apos;) 

def process_item(self, item, spider):
    if item[&apos;title&apos;]:
        found = re.match(&apos;\S* \S*&apos;, str(item[&apos;title&apos;]))
        if found:
            print &apos;---------&apos;, item[&apos;title&apos;]
            line = json.dumps(dict(item), ensure_ascii=False) + &quot;\n&quot; 
            self.file.write(line)   
            return item
        else:
            print &quot;+++++++++ invalid chapter found ++++++++++++++++&quot;

def spider_closed(self, spider):
    self.file.close()
</code></pre><p>首先是在初始化方法里新建一个叫做<code>cn_zhan.json</code>的文件用以收纳抓取的信息，并约定它是<code>utf-8</code>格式（用来显示中文，同时打开它准备写入。第二步在<code>process_item</code>里我们根据正则表达式过滤掉不合规的<code>item</code>，并把合规的<code>item</code>（章节信息）转化成<code>json</code>语句存入之间申明的<code>cn_zhan.json</code>文件里。最后关闭这个文件。</p>
<p>定义好<code>/pipelines.py</code>文件后，我们还需要在<code>/settings.py</code>文件里启用刚定义的输送规则：</p>
<pre><code>ITEM_PIPELINES = {
    #&apos;fiction.pipelines.DuplicatesPipeline&apos;: 100,
    &apos;fiction.pipelines.FictionPipeline&apos;: 300,
}
</code></pre><p>注意在<code>/pipelines.py</code>文件里我们可以申明多个输送规则，例如这里作者还申明了一个去重原则。同时在<code>/settings.py</code>文件里启用时，<code>Scrapy</code>会依照数字从低到高的顺序，通过pipeline，通常将这些数字定义在0-1000范围内</p>
<h3 id="录入到数据库"><a href="#录入到数据库" class="headerlink" title="录入到数据库"></a>录入到数据库</h3><p>这个因为使用的数据库种类不同需要不同的配置，所以就先不讲解了，感兴趣的可以自己去狗哥一下</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>折腾了这么久，激动人心的时刻终于到来了，打开命令行开始运行爬虫，完成之后你就可以在你的文件夹里发现抓取的结果文件了:<code>cn_zhan.json</code></p>
<pre><code>{&quot;url&quot;: [&quot;/0_972/603364.html&quot;], &quot;title&quot;: [&quot;第一章 太阳消失&quot;]}
{&quot;url&quot;: [&quot;/0_972/603365.html&quot;], &quot;title&quot;: [&quot;第二章 全球恐慌&quot;]}
{&quot;url&quot;: [&quot;/0_972/603366.html&quot;], &quot;title&quot;: [&quot;第三章 黑暗时代&quot;]}
{&quot;url&quot;: [&quot;/0_972/603367.html&quot;], &quot;title&quot;: [&quot;第四章 怪物降临&quot;]}
...
</code></pre><p>完美，破费，至此我们的爬虫应该可以说是初步成型了！诸君昌隆！<br><img src="https://cl.ly/3S1k1Z3k3q1i/comic_success_kid.jpg" alt=""></p>
<hr>
<p>This artical is avaliable under <a href="http://wtfpl2.com" target="_blank" rel="external">WTFPL-V2</a>. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - <a href="https://millionaryearl.github.io">Chen’s Alchemy</a> would be appreciated</p>
<hr>
<p>本文链接：<a href="https://millionaryearl.github.io/2016/10/09/python-Scrapy-parser/">https://millionaryearl.github.io/2016/10/09/python-Scrapy-parser/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过上一篇博客的工作，我们拥有了一个简单爬虫。但确实有点简陋的过分了，要啥啥没有，所以今天主要就是简单讲解一下爬虫的解析流程与爬取结果的输出形式。&lt;br&gt;&lt;strong&gt;&lt;em&gt;新任务获得：粗解爬虫解析流程并设置爬取结果的输出&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="https://millionaryearl.github.io/categories/Scrapy/"/>
    
    
      <category term="Python" scheme="https://millionaryearl.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Crawl Web Content - 环境搭配与基础爬虫</title>
    <link href="https://millionaryearl.github.io/2016/10/02/python-Scrapy-framework/"/>
    <id>https://millionaryearl.github.io/2016/10/02/python-Scrapy-framework/</id>
    <published>2016-10-02T03:39:40.000Z</published>
    <updated>2016-10-02T03:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇博客呢，主要是为了响应之前打算自己搞个小说阅览App的想法。作为整个项目的一部分，我们需要自己利用爬虫工具去爬取网上的小说内容。<br><strong><em>新任务获得：制作爬虫并爬取网络内容</em></strong></p>
<a id="more"></a>
<p>打开炼成书，查询 网络爬虫 项目：<br><code>scrapy／ pyspider/ beautifulSoup = 爬虫</code><br>这三个都是比较成熟的python爬虫框架。<a href="https://scrapy.org/" target="_blank" rel="external">scrapy</a> 是其中最出名的，<a href="https://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="external">pyspider</a> 是个国人大神写的，<a href="https://github.com/binux/pyspider" target="_blank" rel="external">beautifulSoup</a> 老实说但就爬虫功能并不完整，主要是还能干点别的。至于你要是问作者为啥推荐的都是python的，php不能做爬虫么？那肯定是可以的啊，只不过作者太菜了，还无力使用世界上最伟大的语言好吧。<br><img src="https://cl.ly/0Q2e06242H0G/comic_hah.jpg" alt=""></p>
<p><strong><em>任务更新：使用Scrapy爬取网络内容</em></strong></p>
<h2 id="配置-Scrapy"><a href="#配置-Scrapy" class="headerlink" title="配置 Scrapy"></a>配置 Scrapy</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先我们肯定是把<code>Python</code>给安装一下的么，不会的伙计们请<a href="http://www.runoob.com/python/python-install.html" target="_blank" rel="external">正面上我</a>,在命令行里输入<code>python</code>，能看到如下就可以了</p>
<pre><code>Python 2.7.12 (default, Jun 29 2016, 14:05:02) 
[GCC 4.2.1 Compatible Apple LLVM 7.3.0 (clang-703.0.31)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; 
</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>由于<code>Scrapy</code>需要 C 语言编译器及其开发前缀。 在 OSX 里这些都是由<code>Apple Xcode development tool</code>提供的， 在命令行里输入：</p>
<pre><code>$ xcode-select --install
</code></pre><p>然后就是使用<code>pip</code>指令，安装<code>Scrapy</code>了，在命令行里输入：</p>
<pre><code>$ pip install Scrapy
</code></pre><p>再输入<code>Scrapy</code>，能看到如下结果就可以了</p>
<pre><code>Scrapy 1.1.3 - no active project
Usage:
    scrapy &lt;command&gt; [options] [args]
...
</code></pre><p>至此么，前期准备工作就都弄好了. 这里我们设定将要爬取的网络内容为这个<a href="http://www.biquge.tw/0_972/" target="_blank" rel="external">小说的章节目录信息</a>P.S.其他系统的安装教程请，<a href="http://scrapy.readthedocs.io/en/latest/intro/install.html" target="_blank" rel="external">正面上我</a><br><strong><em>任务更新：使用Scrapy爬取小说的章节目录信息</em></strong></p>
<h2 id="爬虫制作"><a href="#爬虫制作" class="headerlink" title="爬虫制作"></a>爬虫制作</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>伟大的奥斯忒懦夫司机·作者曾经说过</p>
<blockquote>
<p>在使用爬虫之前，你必须先拥有一个爬虫。而在拥有爬虫之前，你需要先有个放置爬虫的地方。</p>
</blockquote>
<p>所以我们需要先新建一个Scrapy项目。打开命令行，输入命令：</p>
<pre><code>$ scrapy startproject fiction
</code></pre><p>输入命令<code>cd yourProjName</code>进入工程目录后，你就能看到自动创建的主体文件</p>
<ul>
<li><code>scrapy.cfg</code>： 项目的配置文件</li>
<li><code>fiction/</code>：项目的python模块。（我们代码工作主要在这里面）</li>
<li><code>fiction/items.py</code>： 定义抓取的模型</li>
<li><code>fiction/pipelines.py</code>： 模型管道文件.</li>
<li><code>fiction/settings.py</code>： 爬虫配置文件.</li>
<li><code>fiction/spiders/</code>： 放置爬虫代码的目录.</li>
</ul>
<h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p><em>Item</em>是用于承载爬取到的数据的最小容器。和常规的ORM一样，你需要先创建一个<code>scrapy.Item</code>的类，然后定义你需要的类属性。比如对于小说的章节目录，我们需要知道每章的名字与链接地址，所以设定如下：</p>
<pre><code>from scrapy.item import Item, Field
class FictionItem(Item):
    title = Field()
    url = Field()
</code></pre><h3 id="编写爬虫"><a href="#编写爬虫" class="headerlink" title="编写爬虫"></a>编写爬虫</h3><p>一个项目里可以拥有多个爬虫，输入命令<code>$ scrapy genspider -l</code> 我们就能看到<code>Scrapy</code> 提供给我们的四种基本的模版：</p>
<pre><code>Available templates:
    basic
    crawl
    csvfeed
    xmlfeed
</code></pre><p>今次我们就直接使用<code>genspider</code>命令创建最基础的<code>basic</code>模版了，输入命令：</p>
<pre><code>scrapy genspider biquge www.biquge.tw
//formule
scrapy genspider -t crwal exmaple example.com
</code></pre><p>这时候去到<code>/spiders</code>文件夹下，就可以看到这个名为<code>biquge</code>的爬虫文件了</p>
<pre><code># -*- coding: utf-8 -*-
import scrapy
class biqugeSpider(scrapy.Spider):
    name = &quot;biquge&quot;
    allowed_domains = [&quot;http://www.biquge.tw/&quot;]
    start_urls = (
        &apos;http://www.biquge.tw/0_972/&apos;,
    )

    def parse(self, response):
        pass
</code></pre><p>打开爬虫文件，这里我们可以看到三个主要属性和一个主要方法：</p>
<ul>
<li>name : 爬虫的名字与唯一标识，不可以和其他爬虫重复，</li>
<li>allowed_domains : 允许爬取的域名</li>
<li>start_urls : 启动爬取的url列表</li>
<li>parse(): 解析抓到网页</li>
</ul>
<p>粘贴如下代码到<code>fiction/spiders/biquge.py</code>文件中：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> # -*- coding: utf-8 -*-  </div><div class="line"></div><div class="line">from scrapy.spiders import Spider</div><div class="line">from scrapy.selector import Selector</div><div class="line">from fiction.items import FictionItem</div><div class="line"></div><div class="line">class BiqugeSpider(Spider):</div><div class="line">    name = &quot;biquge&quot;</div><div class="line">    allowed_domains = [&quot;http://www.biquge.tw/&quot;]</div><div class="line">    start_urls = (</div><div class="line">        &apos;http://www.biquge.tw/0_972/&apos;,</div><div class="line">    )</div><div class="line"></div><div class="line">    def parse(self, response):</div><div class="line">        chapters = response.xpath(&apos;//dd&apos;)</div><div class="line">        items = []</div><div class="line"></div><div class="line">        for chapter in chapters:</div><div class="line">            item = FictionItem()</div><div class="line">            item[&apos;url&apos;] = chapter.xpath(</div><div class="line">            	&apos;a/@href&apos;).extract()</div><div class="line">            item[&apos;title&apos;] = chapter.xpath(</div><div class="line">            	&apos;a/text()&apos;).extract()</div><div class="line">            items.append(item)</div><div class="line"></div><div class="line">            print item[&apos;url&apos;], item[&apos;title&apos;]</div><div class="line"></div><div class="line">        return items</div></pre></td></tr></table></figure>
<h3 id="开始爬取"><a href="#开始爬取" class="headerlink" title="开始爬取"></a>开始爬取</h3><p>终于可以开始爬数据了，在命令行里输入命令：</p>
<pre><code>$ scrapy crawl biquge -o result.json
</code></pre><p><img src="https://cl.ly/0G3e1B16362x/comic_puke.gif" alt=""></p>
<p>命令行里你应该能看到如下的结果：</p>
<pre><code>2016-09-29 16:56:09 [scrapy] INFO: Scrapy 1.1.3 started (bot: fiction)
2016-09-29 16:56:09 [scrapy] INFO: Optional features available: ...
2016-09-29 16:56:09 [scrapy] INFO: Overridden settings: {}
2016-09-29 16:56:09 [scrapy] INFO: Enabled extensions: ...
2016-09-29 16:56:09 [scrapy] INFO: Enabled downloader middlewares: ...
2016-09-29 16:56:09 [scrapy] INFO: Enabled spider middlewares: ...
2016-09-29 16:56:09 [scrapy] INFO: Enabled item pipelines: ...
2016-09-29 16:56:09 [scrapy] INFO: Spider opened
...
2016-09-29 16:56:09 [scrapy] INFO: Closing spider (finished)
2016-09-29 16:56:16 [scrapy] INFO: Stored json feed (1622 items) in: result.json
</code></pre><p>然后打开你的工作目录，你会发现多了一个<code>result.json</code>文件。打开该文件你就可以看到本次爬取的结果了－小说的章节目录：</p>
<pre><code>[
{&quot;url&quot;: [&quot;/0_972/603364.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u4e00\u7ae0 \u592a\u9633\u6d88\u5931&quot;]},
{&quot;url&quot;: [&quot;/0_972/603365.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u4e8c\u7ae0 \u5168\u7403\u6050\u614c&quot;]},
{&quot;url&quot;: [&quot;/0_972/603366.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u4e09\u7ae0 \u9ed1\u6697\u65f6\u4ee3&quot;]},
{&quot;url&quot;: [&quot;/0_972/603367.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u56db\u7ae0 \u602a\u7269\u964d\u4e34&quot;]},
{&quot;url&quot;: [&quot;/0_972/603368.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u4e94\u7ae0 \u602a\u7269\u9000\u907f&quot;]},
...
</code></pre><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>呃，总体上来说这个基础爬虫就算是完成了，虽然说有一大堆问题，什么章节名乱码啊，爬取数据的解析看不懂啊，pipeline, setting文件怎么用没说啊，但至少咱这个爬虫跑起来了不是，而且也抓到了一堆玩意儿是吧。所以今次就这么多，至于那些坑么，作者会在续集里填上的。最后惯例，诸君昌隆～<br><img src="https://cl.ly/3E1B0x3d1Q3L/comic_disaster_girl.jpg" alt=""></p>
<hr>
<p>This artical is avaliable under <a href="http://wtfpl2.com" target="_blank" rel="external">WTFPL-V2</a>. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - <a href="https://millionaryearl.github.io">Chen’s Alchemy</a> would be appreciated</p>
<hr>
<p>本文链接：<a href="https://millionaryearl.github.io/2016/10/02/python-Scrapy-framework/">https://millionaryearl.github.io/2016/10/02/python-Scrapy-framework/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇博客呢，主要是为了响应之前打算自己搞个小说阅览App的想法。作为整个项目的一部分，我们需要自己利用爬虫工具去爬取网上的小说内容。&lt;br&gt;&lt;strong&gt;&lt;em&gt;新任务获得：制作爬虫并爬取网络内容&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="https://millionaryearl.github.io/categories/Scrapy/"/>
    
    
      <category term="Python" scheme="https://millionaryearl.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own Blog  - 个性化设置(三)</title>
    <link href="https://millionaryearl.github.io/2016/09/25/hexo-Blog-SEO/"/>
    <id>https://millionaryearl.github.io/2016/09/25/hexo-Blog-SEO/</id>
    <published>2016-09-25T03:10:40.000Z</published>
    <updated>2016-09-25T03:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有小伙伴反映，啊那个兄台啊，你这个博客还算阔以，就是访问起来也忒麻烦了。百度和狗哥上找不捉，这个网址这么难记，小伙伴们不能日日瞻仰，很是为难呀。<br><strong><em>新任务获得：配置SEO</em></strong></p>
<a id="more"></a>
<h2 id="搜索引擎优化"><a href="#搜索引擎优化" class="headerlink" title="搜索引擎优化"></a>搜索引擎优化</h2><h3 id="修改公网网址"><a href="#修改公网网址" class="headerlink" title="修改公网网址"></a>修改公网网址</h3><p>这个其实还是属于前篇里说的基础键值配置，找到主工程目录里的 <code>_config.yml</code> 文件，然后修改</p>
<pre><code>url: https://millionaryearl.github.io（改成你的域名）
</code></pre><p>至于域名购买么也简单得很，<a href="https://www.godaddy.com/" target="_blank" rel="external">狗爹</a> 或者 <a href="https://www.aliyun.com" target="_blank" rel="external">阿里云</a> 上买一个好了么</p>
<h2 id="提交狗哥"><a href="#提交狗哥" class="headerlink" title="提交狗哥"></a>提交狗哥</h2><h3 id="确认blog是否被收录。"><a href="#确认blog是否被收录。" class="headerlink" title="确认blog是否被收录。"></a>确认blog是否被收录。</h3><p>打开<a href="https://www.google.com" target="_blank" rel="external">狗哥搜索引擎</a>，输入 <code>site:yourwebaddress</code>. 要有结果么就继续，没有么就要去查查你的网站是否有部署问题了</p>
<h3 id="验证网站"><a href="#验证网站" class="headerlink" title="验证网站"></a>验证网站</h3><p>通过验证网站，可以证明你是该域名的拥有者，可以做为站长管理自己的网站－添加子节点啊，查流量啊，访问量啊什么的。<br>前往 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">狗哥站长</a> 登陆后开始验证。<br><img src="https://cl.ly/0o2L3j1u2O2E/hexo_4_verifyWebHost.png" alt=""></p>
<h3 id="选择验证方式"><a href="#选择验证方式" class="headerlink" title="选择验证方式"></a>选择验证方式</h3><p>验证方式有四种－ <strong><em>HTML标记</em></strong>，<strong><em>域名提供商</em></strong>， <strong><em>Google Analytics(分析)</em></strong> 和 <strong><em>Google 跟踪代码管理器</em></strong>。 这里我们使用第一种<br><img src="https://cl.ly/0n3I3h1F2a0k/hexo_4_2.png" alt=""></p>
<p>按照狗哥的要求，下载验证文件后，传到github里，再去浏览器里打开一下，那个验证按钮应该就亮了。都弄好之后，你就能看到自己的网站了<br><img src="https://cl.ly/0p0R2q3p3X3F/hexo_4_3.png" alt=""></p>
<h3 id="上传sitemap"><a href="#上传sitemap" class="headerlink" title="上传sitemap"></a>上传sitemap</h3><p>简单点说，sitemap文件就是你的站点地图，做为引索可以很方便的把你的网站内容的组织架构告知狗哥和其他搜索引擎。至于这个sitemap从哪里来么，我们需要</p>
<ol>
<li><p>安装插件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div></pre></td></tr></table></figure>
</li>
<li><p>在 <strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  sitemap:</div><div class="line">path: sitemap.xml</div></pre></td></tr></table></figure>
</li>
<li><p>然后<code>hexo g</code>一下，你就能在工程主目录下看到 <code>sitemap.xml</code>文件了</p>
</li>
<li>最后回到狗哥站长的界面里，添加<code>sitemap.xml</code>的文件途径<br><img src="https://cl.ly/2y3G2X1h1N1B/hexo_4_4.png" alt=""></li>
</ol>
<h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>至此我们的工作就算完成了，等待差不多一天之后，你就可以在狗哥搜索你的博客名了，基本上第一个就是你的博客站啦<br><img src="https://cl.ly/0q2S3d2a1P1K/hexo_4_5.png" alt=""></p>
<h2 id="提交百度"><a href="#提交百度" class="headerlink" title="提交百度"></a>提交百度</h2><p>这个因为github把百度爬虫给墙了，所以上面的路径对于百度走不通(会卡在网站验证那一步)。解决起来有点绕，核心思想是，通过cdn或者镜像托管，让百度爬虫可以抓取到我们的博客站。具体的实践攻略博主最近有点忙就先鸽了</p>
<h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>至此，我们的博客站主体配置工作就算告一段落了，剩下的活儿就写写博客了。所以hexo篇，至此暂时完结，感觉兴趣的伙计可以给我留言。诸君，武运昌隆！<br><img src="https://cl.ly/03081Q2b3D1L/comic_lol.gif" alt=""></p>
<hr>
<p>This artical is avaliable under <a href="http://wtfpl2.com" target="_blank" rel="external">WTFPL-V2</a>. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - <a href="https://millionaryearl.github.io">Chen’s Alchemy</a> would be appreciated</p>
<hr>
<p>本文链接：<a href="https://millionaryearl.github.io/2016/09/25/hexo-Blog-SEO/">https://millionaryearl.github.io/2016/09/25/hexo-Blog-SEO/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有小伙伴反映，啊那个兄台啊，你这个博客还算阔以，就是访问起来也忒麻烦了。百度和狗哥上找不捉，这个网址这么难记，小伙伴们不能日日瞻仰，很是为难呀。&lt;br&gt;&lt;strong&gt;&lt;em&gt;新任务获得：配置SEO&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="https://millionaryearl.github.io/categories/Blog/"/>
    
    
      <category term="Hexo" scheme="https://millionaryearl.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own Blog  - 个性化设置(二)</title>
    <link href="https://millionaryearl.github.io/2016/09/18/hexo-Blog-method/"/>
    <id>https://millionaryearl.github.io/2016/09/18/hexo-Blog-method/</id>
    <published>2016-09-18T09:01:40.000Z</published>
    <updated>2016-09-18T09:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>主题相关的界面工作完成之后，这个博客总算是有点样子。但是我看来看去，赶脚似乎大概眉笔好像有那么一点点简陋的哇。所以这一期我们打算看看有哪些附属功能可以加到博客上。<br><strong><em>新任务获得：美化个人网站-附属功能</em></strong> </p>
<a id="more"></a>
<h2 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h2><h3 id="评论模块"><a href="#评论模块" class="headerlink" title="评论模块"></a>评论模块</h3><p>有的theme可能带有评论，而有的没有。可选的插件有 <a href="https://disqus.com" target="_blank" rel="external"><strong><em>DISQUS</em></strong></a> （更简洁偏国外） 和 <a href="http://duoshuo.com" target="_blank" rel="external"><strong><em>多说</em></strong></a>（更社交偏国内）, 这里我们选用 <strong>DISQUS</strong></p>
<ol>
<li>在<strong>DISQUS</strong>上注册账号</li>
<li>在<strong>DISQUS</strong>上注册一个网站,得到网站的shortname</li>
<li>在工程目录里找到<code>_config.yml</code>，加入如下代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Disqus</div><div class="line">disqus_shortname: shortname</div></pre></td></tr></table></figure>
<ol>
<li>更多评论样式设置或者相关疑问，<a href="http://morris821028.github.io/2014/04/12/web/hexo-comment/" target="_blank" rel="external">正面上我</a></li>
</ol>
<h3 id="打赏模块"><a href="#打赏模块" class="headerlink" title="打赏模块"></a>打赏模块</h3><p>这个虽然说是正常人都不太会用的废物功能，但万一呢，是吧。万一又个慧眼独具，目光深邃的好汉看出来本人骨骼精奇，死乞白赖的非要给我打上呢是吧，所以本着用户至上的原则，咱还是加上这个模块吧</p>
<p>首先去看下<code>/themes/your_theme/layout/macro</code>途径下有没有 <code>reward.swig</code>文件，没有的话就新建，内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&#123;% if theme.alipay or theme.wechatpay %&#125;</div><div class="line">  &lt;div style=&quot;padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;&quot;&gt;</div><div class="line">    &lt;div&gt;&#123;&#123; theme.reward_comment &#125;&#125;&lt;/div&gt;</div><div class="line">    &lt;button id=&quot;rewardButton&quot; disable=&quot;enable&quot; onclick=&quot;var qr = document.getElementById(&apos;QR&apos;); if (qr.style.display === &apos;none&apos;) &#123;qr.style.display=&apos;block&apos;;&#125; else &#123;qr.style.display=&apos;none&apos;&#125;&quot;&gt;</div><div class="line">      &lt;span&gt;赏&lt;/span&gt;</div><div class="line">    &lt;/button&gt;</div><div class="line">    &lt;div id=&quot;QR&quot; style=&quot;display: none;&quot;&gt;</div><div class="line">      &#123;% if theme.wechatpay %&#125;</div><div class="line">        &lt;div id=&quot;wechat&quot; style=&quot;display: inline-block&quot;&gt;</div><div class="line">          &lt;img id=&quot;wechat_qr&quot; src=&quot;&#123;&#123; theme.wechatpay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; WeChat Pay&quot;/&gt;</div><div class="line">          &lt;p&gt;微信打赏&lt;/p&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">      &#123;% endif %&#125;</div><div class="line">      &#123;% if theme.alipay %&#125;</div><div class="line">        &lt;div id=&quot;alipay&quot; style=&quot;display: inline-block&quot;&gt;</div><div class="line">          &lt;img id=&quot;alipay_qr&quot; src=&quot;&#123;&#123; theme.alipay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Alipay&quot;/&gt;</div><div class="line">          &lt;p&gt;支付宝打赏&lt;/p&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">      &#123;% endif %&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p>然后看下同路径下的<code>post.swig</code>文件, 确保在<code>&lt;footer class=&quot;post-footer&quot;&gt;</code>之前有这么一段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;% if not is_index %&#125;</div><div class="line">     &#123;% include &apos;reward.swig&apos; %&#125;</div><div class="line">   &#123;% endif %&#125;</div><div class="line"> &lt;/div&gt;</div></pre></td></tr></table></figure>
<p>再后去<strong>站点配置文件</strong><code>(工程主目录下的_config.yml)</code>，设置如下键值对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Donate 文章末尾显示打赏按钮</div><div class="line">reward_comment: 我知道是不会有人点的，但万一有人想不开呢？</div><div class="line">wechatpay: https://cl.ly/3W3I3O3t1622/wexinpay.JPG</div><div class="line">alipay: https://cl.ly/3t1O403j2P1F/alipay.JPG</div></pre></td></tr></table></figure>
<p>最后记得把那两个二维码的图片地址换成你自己的，不然就算你骨骼精奇，人也是把钱汇给我了。。。当然你要真倔强不换，我也是很欢迎滴。<br><img src="https://cl.ly/0a0n3y3t3136/comic_spiderman.jpg" alt=""></p>
<h3 id="RSS开启"><a href="#RSS开启" class="headerlink" title="RSS开启"></a>RSS开启</h3><p>这RSS开启了之后么，就可以方便别人订阅你的博客了，要装上也挺简单。先去命令行里主工程目录下运行</p>
<pre><code>$ npm install hexo-generator-feed --save
</code></pre><p>然后去<strong>站点配置文件</strong><code>(工程主目录下的_config.yml)</code>里配置一下. P.S.似乎<code>Next</code>主题可以跳过这步，因为在<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里，已经设好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">feed:</div><div class="line">    type: atom</div><div class="line">    path: atom.xml</div><div class="line">    limit: 20</div></pre></td></tr></table></figure></p>
<h3 id="社交连接"><a href="#社交连接" class="headerlink" title="社交连接"></a>社交连接</h3><p>去到<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里，先找到<code>social</code>键，按如下格式添加键值对</p>
<pre><code>social_name: link_address
e.g.
GitHub: https://github.com/Millionaryearl
Weibo: http://weibo.com/2334525960/profile?topnav=1&amp;wvr=6&amp;is_all=1
Personal: http://dukewei.typify.io
</code></pre><p>然后去给对应的连接加上图标，这个图标和上篇里菜单项目图标一样，也是由 <a href="http://fontawesome.io" target="_blank" rel="external">Font Awesome</a> 提供的</p>
<pre><code>social_name: icon_name
(e.g.)
GitHub: github
Twitter: twitter
Weibo: weibo
Personal: home
</code></pre><h3 id="结尾样式-版权说明"><a href="#结尾样式-版权说明" class="headerlink" title="结尾样式-版权说明"></a>结尾样式-版权说明</h3><p>在主工程目录下，新建一个名为<code>scripts</code>的文件夹，在其中，新建一个AddTail.js脚本文件，内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// Filename: AddTail.js</div><div class="line"></div><div class="line">// Add a tail to every post from tail.md</div><div class="line">// Great for adding copyright info</div><div class="line"></div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">hexo.extend.filter.register(&apos;before_post_render&apos;, function(data)&#123;</div><div class="line">	if(data.copyright == false) return data;</div><div class="line">	</div><div class="line">	// Add seperate line</div><div class="line">	data.content += &apos;\n___\n&apos;;</div><div class="line">	</div><div class="line">	// Try to read tail.md</div><div class="line">	try &#123;</div><div class="line">		var file_content = fs.readFileSync(&apos;tail.md&apos;);</div><div class="line">		if(file_content &amp;&amp; data.content.length &gt; 50) </div><div class="line">		&#123;</div><div class="line">			data.content += file_content;</div><div class="line">		&#125;</div><div class="line">	&#125; catch (err) &#123;</div><div class="line">		if (err.code !== &apos;ENOENT&apos;) throw err;</div><div class="line">		</div><div class="line">		// No process for ENOENT error</div><div class="line">	&#125;</div><div class="line"></div><div class="line">  	// 添加具体文章链接, 不需要去掉即可</div><div class="line">	var permalink = &apos;\n本文链接：&apos; + data.permalink;</div><div class="line">	data.content += permalink;</div><div class="line">  </div><div class="line">	return data;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然后在工程主目录下新建一个<code>tail.md</code>文件，其中写上你的博客结尾内容，比如作者就写了下版权的破事儿</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>感觉用 <strong><em>NEXT</em></strong> 的博主特别多，所以咱要稍微搞些不一样的东西，比如换换背景什么的。<br>首先去<code>/themes/next/source/js/src</code>路径下新建你的样式文件，例如<code>particle.js</code></p>
<pre><code>!function(){function n(n,e,t){return n.getAttribute(e)||t}function e(n){return document.getElementsByTagName(n)}function t(){var t=e(&quot;script&quot;),o=t.length,i=t[o-1];return{l:o,z:n(i,&quot;zIndex&quot;,-1),o:n(i,&quot;opacity&quot;,.5),c:n(i,&quot;color&quot;,&quot;0,0,0&quot;),n:n(i,&quot;count&quot;,99)}}function o(){c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function i(){l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i){for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=&quot;rgba(&quot;+m.c+&quot;,&quot;+(t+.2)+&quot;)&quot;,l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)}),r(i)}var c,a,u=document.createElement(&quot;canvas&quot;),m=t(),d=&quot;c_n&quot;+m.l,l=u.getContext(&quot;2d&quot;),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n){window.setTimeout(n,1e3/45)},x=Math.random,w={x:null,y:null,max:2e4};u.id=d,u.style.cssText=&quot;position:fixed;top:0;left:0;z-index:&quot;+m.z+&quot;;opacity:&quot;+m.o,e(&quot;body&quot;)[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n){n=n||window.event,w.x=n.clientX,w.y=n.clientY},window.onmouseout=function(){w.x=null,w.y=null};for(var y=[],s=0;m.n&gt;s;s++){var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push({x:f,y:h,xa:g,ya:p,max:6e3})}setTimeout(function(){i()},100)}();
</code></pre><p>然后在<code>/themes/next/layout</code>路径下的<code>_layout.swig</code>文件里，最后的<code>body</code>标签上，引用我们刚新建的js文件</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>至此基本上博客的功能就比较全了，其他的功能也还有很多，比如 PV啦，友链啦，搜索啦，笔者晚点会补上的。这期就先这样了，诸君，好运。<br><img src="https://cl.ly/1V0a2f2p0a1y/comic_dance.gif" alt=""></p>
<hr>
<p>This artical is avaliable under <a href="http://wtfpl2.com" target="_blank" rel="external">WTFPL-V2</a>. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - <a href="https://millionaryearl.github.io">Chen’s Alchemy</a> would be appreciated</p>
<hr>
<p>本文链接：<a href="https://millionaryearl.github.io/2016/09/18/hexo-Blog-method/">https://millionaryearl.github.io/2016/09/18/hexo-Blog-method/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主题相关的界面工作完成之后，这个博客总算是有点样子。但是我看来看去，赶脚似乎大概眉笔好像有那么一点点简陋的哇。所以这一期我们打算看看有哪些附属功能可以加到博客上。&lt;br&gt;&lt;strong&gt;&lt;em&gt;新任务获得：美化个人网站-附属功能&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="https://millionaryearl.github.io/categories/Blog/"/>
    
    
      <category term="Hexo" scheme="https://millionaryearl.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own Blog  - 个性化设置(一)</title>
    <link href="https://millionaryearl.github.io/2016/09/11/hexo-Blog-interface/"/>
    <id>https://millionaryearl.github.io/2016/09/11/hexo-Blog-interface/</id>
    <published>2016-09-11T06:29:52.000Z</published>
    <updated>2016-09-11T06:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>有了基础的博客框架之后，我们就要去做一些个性化的设置了。毕竟同行千千万，内容取胜不太现实，所以咱就剑走偏锋把自己的博客给搞漂亮一些得了。<br><strong><em>新任务获得：美化个人网站-界面</em></strong> </p>
<a id="more"></a>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ol>
<li>在 <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">正面上我</a> 寻找喜欢的主题，这里我们使用 <a href="http://theme-next.iissnan.com" target="_blank" rel="external">NEXT</a> 主题（活跃度最好，API也比较全，推荐一哈）</li>
<li>下载下来，保存到<code>主工程目录下 \themes</code>文件夹</li>
<li><p>在 <code>主工程目录下的_config.yml</code> 文件里修改 <code>themes</code> 键值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: next //themes文件夹中对应文件夹的名称</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="选定Scheme"><a href="#选定Scheme" class="headerlink" title="选定Scheme"></a>选定Scheme</h3><p>Scheme 是 NexT 提供的一种特性，简单点说呢就是这个主题可以通过改变 <code>Scheme</code> 的值来变成三种不同的布局：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>在 <strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里修改 <code>scheme</code> 键值。</p>
<pre><code>#scheme: Muse
#scheme: Mist
scheme: Pisces
</code></pre><h3 id="站点语言"><a href="#站点语言" class="headerlink" title="站点语言"></a>站点语言</h3><p>通过修改 <strong>站点配置文件</strong><code>(工程主目录下的_config.yml)</code>，将<code>language</code> 设置成所需的语言编码</p>
<pre><code>language: zh-Hans
</code></pre><p>可选的语言编码如下表:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>English</td>
<td>en</td>
</tr>
<tr>
<td>简体中文</td>
<td>zh-Hans</td>
</tr>
<tr>
<td>Français</td>
<td>fr-FR</td>
</tr>
<tr>
<td>Português</td>
<td>pt</td>
</tr>
<tr>
<td>繁體中文</td>
<td>zh-hk 或者 zh-tw</td>
</tr>
<tr>
<td>Русский язык</td>
<td>ru</td>
</tr>
<tr>
<td>Deutsch</td>
<td>de</td>
</tr>
<tr>
<td>日本語</td>
<td>ja</td>
</tr>
<tr>
<td>Indonesian</td>
<td>id</td>
</tr>
</tbody>
</table>
<h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><ol>
<li><p>设置菜单项目. 找到<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里<code>menu</code>字段，按照如下格式加入菜单项及其文件路径. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu_option : folder_directory</div><div class="line">(e.g.)</div><div class="line">categories : /categories</div></pre></td></tr></table></figure>
</li>
<li><p>设置菜单项目. 注意大部分菜单途径需要用户自己生成，在命令行工程主路径下，  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo new page &quot;menu_option&quot;</div><div class="line">(e.g.)</div><div class="line">$ hexo new page &quot;categories&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>设置菜单项目. 然后编辑下 <code>/source/menu_option／index.md</code>， 大概弄成这样就成了,</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: menu_option</div><div class="line">date: 自动生成的</div><div class="line">type: &quot;menu_option&quot;</div><div class="line">comments: false (如果你加了评论的话)</div><div class="line">---</div><div class="line">e.g.</div><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2016-09-18 16:12:40</div><div class="line">type: &quot;categories&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure>
</li>
<li><p>设置菜单项目名称. 找到<strong>主题对应语言文件</strong><code>(/themes/next/languages/your_language_name.yml)</code>里<code>menu</code>字段，按照如下格式加入菜单项名称,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu_option : menu_name</div><div class="line">(e.g.)</div><div class="line">categories: 分类</div></pre></td></tr></table></figure>
</li>
<li><p>设置菜单项目图标. 找到<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里<code>menu_icons</code>字段，按照如下格式加入菜单项图标名称。这里的图标名称都是由 <a href="http://fontawesome.io" target="_blank" rel="external">Font Awesome</a> 提供的,</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu_option : menu_icon_name</div><div class="line">(e.g.)</div><div class="line">categories: th</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><ol>
<li><p>找到<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里<code>avatar</code>字段, 设置图片地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">avatar: /images/avatar.png</div></pre></td></tr></table></figure>
</li>
<li><p>把你的头像文件命名为 <code>avatar.png</code> 然后丢到 <code>(/themes/next/source/images)</code>文件夹里</p>
</li>
</ol>
<h3 id="颜色字体"><a href="#颜色字体" class="headerlink" title="颜色字体"></a>颜色字体</h3><p>这个其实算是最简单的差异化修改了，只要找到<code>/themes/next/source/css/variables/base.styl</code>文件里，把对应的颜色和字体改成自己想要的值就可以了，例如作者就修改了</p>
<pre><code>$black-light  = #336699
$black-deep   = #660066
</code></pre><h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>至此我们的博客站在界面布局方面就算是大功告成了，其实本期我们的主要工作就是把<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>和 <strong>站点配置文件</strong><code>(工程主目录下的_config.yml)</code>的一些属性给配置起来，其他的很多配置工作都是通过修改其中对应的键值实现的，具体的键名解析请 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">正面上我</a>。 </p>
<p>欣赏一下，感悟一下，陶醉一下，然后分享给你的小伙伴们吧，一大波崇拜的目光即将到来，嘿嘿嘿。</p>
<p><img src="https://cl.ly/0k390e3v3z1v/comic_beautiful.jpg" alt=""></p>
<hr>
<p>This artical is avaliable under <a href="http://wtfpl2.com" target="_blank" rel="external">WTFPL-V2</a>. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - <a href="https://millionaryearl.github.io">Chen’s Alchemy</a> would be appreciated</p>
<hr>
<p>本文链接：<a href="https://millionaryearl.github.io/2016/09/11/hexo-Blog-interface/">https://millionaryearl.github.io/2016/09/11/hexo-Blog-interface/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有了基础的博客框架之后，我们就要去做一些个性化的设置了。毕竟同行千千万，内容取胜不太现实，所以咱就剑走偏锋把自己的博客给搞漂亮一些得了。&lt;br&gt;&lt;strong&gt;&lt;em&gt;新任务获得：美化个人网站-界面&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="https://millionaryearl.github.io/categories/Blog/"/>
    
    
      <category term="Hexo" scheme="https://millionaryearl.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own Blog  - 建站并部署到Github</title>
    <link href="https://millionaryearl.github.io/2016/09/04/hexo-Blog-framework/"/>
    <id>https://millionaryearl.github.io/2016/09/04/hexo-Blog-framework/</id>
    <published>2016-09-04T05:35:02.000Z</published>
    <updated>2016-09-04T05:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直打算搞一个自己的技术博客站，比起用什么简书啊，CSDN的第三方平台，直接高冷的丢出去一个自制的博客站，简直就是装比于无形，想想就带感好吧。<br><strong><em>新任务获得：部署个人网站</em></strong></p>
<a id="more"></a>
<p>嗯常规套路先看炼成书，查阅 个人网站 项：<br><code>公网域名 ＋ 服务器 ＋ 网站代码 ＝ 个人网站（常规合成法则）</code><br>呃，公网域名么 <a href="https://www.godaddy.com/" target="_blank" rel="external">狗爹</a> 上或许能找到便宜的。服务器，呃，<a href="https://aws.amazon.com" target="_blank" rel="external">AWS</a>好像有点贵，<a href="https://www.aliyun.com" target="_blank" rel="external">aliyun</a>凑合吧。网站代码，呃，不就是 <code>H5+CSS+JS/AJAX</code> 么，小意思。。。。。。个屁。哥是写Swift的，自己去搞这些web相关的，要搞死哥啊。再翻翻炼成书:<br><code>hexo（网站代码） + github（公共域名 &amp; 服务器） = 个人网站（黑暗合成法则）</code> </p>
<p><img src="https://cl.ly/022C2w20262o/commic_wow.jpg" alt=""></p>
<p><strong><em>任务更新：使用 <a href="https://hexo.io/docs/" target="_blank" rel="external">Hexo</a> 和 <a href="https://github.com" target="_blank" rel="external">Github</a> 制成个人博客。 </em></strong></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Step-1-开发环境"><a href="#Step-1-开发环境" class="headerlink" title="Step.1 开发环境"></a>Step.1 开发环境</h3><ol>
<li><strong>Node.js</strong>     <a href="https://nodejs.org/en/download/package-manager/#osx" target="_blank" rel="external">安装指南</a></li>
<li><strong>Git</strong>         <a href="https://git-scm.com/book/zh/v1/起步-安装-Git" target="_blank" rel="external">安装指南</a></li>
<li><p>运行如下命令不报错即配置成功。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm -v</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git --version</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Step-2-GitHub"><a href="#Step-2-GitHub" class="headerlink" title="Step.2 GitHub"></a>Step.2 GitHub</h3><ol>
<li>新建一个代码仓，命名为<code>yourname.github.io</code></li>
<li><p>开启 <strong>gh-pages</strong> 功能</p>
<ul>
<li>开启 Reposity <strong>Setting</strong> 页面如下</li>
<li>点击 <strong>Automatic page generator</strong></li>
</ul>
<p><img src="https://cl.ly/240P2i1D0b3j/hexo_1.png" alt=""></p>
</li>
<li><p>能够正常访问网址: <code>yourname.github.io</code> ，即配置成功。<strong><em>这个地址将成为你的博客网址（可以修改）</em></strong><br><img src="https://cl.ly/2L1R2X0e2j0U/comic_brilliant.jpg" alt=""></p>
</li>
</ol>
<h3 id="Step-3-Hexo"><a href="#Step-3-Hexo" class="headerlink" title="Step.3 Hexo"></a>Step.3 Hexo</h3><ol>
<li>新建一个工作目录，打开命令行并切换到新建的工作目录途径</li>
<li>安装 <strong>Hexo</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="Step-1-新建一个网站"><a href="#Step-1-新建一个网站" class="headerlink" title="Step.1 新建一个网站"></a>Step.1 新建一个网站</h3><ol>
<li>在命令行里执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Step-2-本地测试"><a href="#Step-2-本地测试" class="headerlink" title="Step.2 本地测试"></a>Step.2 本地测试</h3><ol>
<li>在命令行里执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">$ hexo s</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果能看到提示：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code>你就可以去浏览器里打开<code>http://localhost:4000/</code>，欣赏你的个人博客了</p>
<p><img src="https://cl.ly/1o0m2K121V18/hexo_2.png" alt=""></p>
<h3 id="Step-3-Github部署"><a href="#Step-3-Github部署" class="headerlink" title="Step.3 Github部署"></a>Step.3 Github部署</h3><ol>
<li><p>需要为自己配置身份信息，打开命令行，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;yourname&quot;</div><div class="line">git config --global user.email &quot;youremail&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>去工程目录里找到 <code>_config.yml</code> 文件，修改下列属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@github.com:yourname/yourname.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
</li>
<li><p>在命令行里执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo d</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果能看到提示 <code>INFO  Deploy done: git</code> 你就可以去浏览器里打开 <code>yourname.github.io</code>，继续欣赏你的个人博客了。</p>
<p><img src="https://cl.ly/441e3k3O1r2G/commic_yeah.jpg" alt=""></p>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="Q1-命令行总是指令错误"><a href="#Q1-命令行总是指令错误" class="headerlink" title="Q1: 命令行总是指令错误"></a>Q1: 命令行总是指令错误</h3><ol>
<li><p>首先你的确保命令行的路径是你的工作目录（工程文件夹）的途径，在命令行里输入下列命令确认</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pwd</div></pre></td></tr></table></figure>
</li>
<li><p>其次确保 <code>node.js</code> &amp; <code>git</code> &amp; <code>hexo</code> 确实安装成功了，详见上述准备环节</p>
</li>
</ol>
<h3 id="Q2-Github部署时，总是提示-“Permission-Denied”"><a href="#Q2-Github部署时，总是提示-“Permission-Denied”" class="headerlink" title="Q2: Github部署时，总是提示 “Permission Denied”"></a>Q2: Github部署时，总是提示 “Permission Denied”</h3><p>这个是因为的Github的SSH连接授权有问题，需要确认本地机器上的ssh公钥与Github上的私钥是匹配的。如果实在无法确认的话，就直接去换套新的吧（作者就折腾了半天），<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="external">正面上我</a> 。</p>
<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><ol>
<li><p>在命令行里执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>或者直接在工程目录的 <code>/source/_posts/</code> 下，新建 newblog.md 文件</p>
</li>
<li>编辑内容</li>
<li>在命令行里执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo d</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p><strong>Hexo</strong> 总体上来说还算是个挺不错的框架的，能玩的东西很多，插件，主题等等等等，想要学习更多的可以去 <a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo官网</a>看看。</p>
<p>完结，撒花，鼓掌～～～</p>
<hr>
<p>This artical is avaliable under <a href="http://wtfpl2.com" target="_blank" rel="external">WTFPL-V2</a>. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - <a href="https://millionaryearl.github.io">Chen’s Alchemy</a> would be appreciated</p>
<hr>
<p>本文链接：<a href="https://millionaryearl.github.io/2016/09/04/hexo-Blog-framework/">https://millionaryearl.github.io/2016/09/04/hexo-Blog-framework/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直打算搞一个自己的技术博客站，比起用什么简书啊，CSDN的第三方平台，直接高冷的丢出去一个自制的博客站，简直就是装比于无形，想想就带感好吧。&lt;br&gt;&lt;strong&gt;&lt;em&gt;新任务获得：部署个人网站&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="https://millionaryearl.github.io/categories/Blog/"/>
    
    
      <category term="Hexo" scheme="https://millionaryearl.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Swift Notes - 阿里云推送SDK</title>
    <link href="https://millionaryearl.github.io/2016/09/01/swift-APNS-aliyun/"/>
    <id>https://millionaryearl.github.io/2016/09/01/swift-APNS-aliyun/</id>
    <published>2016-09-01T01:21:10.000Z</published>
    <updated>2016-09-01T01:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>新项目里的消息推送功能，公司技术部开会讨论后决定让 极光，百度，aws都歇菜，取而代之的是尝试 使用阿里云推送SDK。所以今天就简单记录下调试过程。<br><strong><em>新任务获得：使用阿里云推送SDK实现消息推送功能～</em></strong></p>
<a id="more"></a>
<p>嗯常规套路先看官方文档 <a href="https://help.aliyun.com/document_detail/30072.html?spm=5176.doc30071.6.156.YoX0P8" target="_blank" rel="external">正面上我</a> 。 嗯，很详细，很耐斯，很桥豆麻袋？库文件是OC写的？？？</p>
<p><img src="https://cl.ly/hRAS/ExcuseMe.jpeg" alt=""></p>
<p>坑爹啊，哥的项目都是swift写的啊。呃。。。。。。。。。好吧，也许加一个桥接就可以了。任务变更：桥接阿里云推送SDK（OC版）到Swift工程里，而后实现消息推送功能～</p>
<p><img src="https://cl.ly/hREs/challenge-accepted-meme.jpg" alt=""></p>
<h2 id="Ready-to-work"><a href="#Ready-to-work" class="headerlink" title="Ready to work"></a>Ready to work</h2><p>所谓工欲善其事，必先利其器。而且消息推送功能本身就是配置打过逻辑代码的功能，所以我们先要把准备工作做好。</p>
<hr>
<h3 id="Step-1-准备certificate文件"><a href="#Step-1-准备certificate文件" class="headerlink" title="Step.1 - 准备certificate文件"></a>Step.1 - 准备certificate文件</h3><p>由于消息推送功能的实现，涉及到Apple的官方资源（感兴趣的同志们可以自行去谷歌APNS），所以需要准备特别的证书文件：<strong><em>development certificate x1</em></strong>， <strong><em>distribution certificate x1</em></strong>。然后这两个文件具体怎么获得呢，请 <a href="https://help.aliyun.com/document_detail/30071.html?spm=5176.doc30072.6.155.ItR8Ib" target="_blank" rel="external">正面上我</a> 。</p>
<h3 id="Step-2-获得AppKey-AppSecret"><a href="#Step-2-获得AppKey-AppSecret" class="headerlink" title="Step.2 - 获得AppKey, AppSecret"></a>Step.2 - 获得AppKey, AppSecret</h3><p>这个appkey 和appsecret 是做啥的呢，嗯简单说就是这两个字串是阿里云用来标记你的app的，万一推错了就不好嘛，稍后我们会用点。那么问题又来了这两个字串那里搞呢？</p>
<p>支线任务获得：寻找NPC -公司的推送服务后台开发人员，交付 <strong><em>development certificate x1</em></strong>， <strong><em>distribution certificate x1</em></strong>后，获得 <strong><em>AppKey x1</em></strong>, <strong><em>AppSecret x1</em></strong>.</p>
<h3 id="Step-3-配置App"><a href="#Step-3-配置App" class="headerlink" title="Step.3 - 配置App"></a>Step.3 - 配置App</h3><p>配置App这个就简单了，打开你的项目代码。先把开发团队调到你们的公司</p>
<p><img src="https://cl.ly/hQyC/aliyun_1.jpeg" alt=""></p>
<p>然后打开 Post Notifications 功能</p>
<p><img src="https://cl.ly/hRCF/aliyun_2.png" alt=""></p>
<h3 id="Step-4-引入阿里云SDK"><a href="#Step-4-引入阿里云SDK" class="headerlink" title="Step.4 - 引入阿里云SDK"></a>Step.4 - 引入阿里云SDK</h3><p>下载好压缩包打开，获得四个库文件，然后全部拖到你的项目工程里去。再然后么把 build settings 里的 Enable Bitcode 给关了。最后再转到 Build Phases 里面的 Link Binary With libraries， 加入四个依赖的系统库: libz.tbd，libresolv.tbd，CoreTelephony.framework，SystemConfiguration.framework 。</p>
<hr>
<p>好啦，到此基本上所有的准备工作都做好了。接下来我们就可以开始写代码了。P.S. <del>其实上面的都可以在阿里云文档里看到，哥只是拿来凑字的</del>～～</p>
<h2 id="Core-Work"><a href="#Core-Work" class="headerlink" title="Core Work"></a>Core Work</h2><h3 id="Step-1-桥接"><a href="#Step-1-桥接" class="headerlink" title="Step.1 - 桥接"></a>Step.1 - 桥接</h3><p>先建立一个 Header File，命名为 YourProjectName-Bridging-Header.h 。 </p>
<p><img src="https://cl.ly/hRGV/aliyun_3.jpeg" alt=""></p>
<p>然后呢去到 Build Setting里，找到 Objective-C Bridging Header 填入刚才的文件名</p>
<p><img src="https://cl.ly/hRAR/aliyun_4.jpeg" alt=""></p>
<p>最后在刚才的桥接文件里，引入阿里云推送的库<code>#import &lt;CloudPushSDK/CloudPushSDK.h&gt;</code>, 这样就可以用SDK里的方法了。</p>
<h3 id="Step-2-配置推送"><a href="#Step-2-配置推送" class="headerlink" title="Step.2 - 配置推送"></a>Step.2 - 配置推送</h3><p>先在APP启动时调用配置方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">let aliyunpush_AppKey = &quot;23448723&quot;</div><div class="line">let aliyunpush_AppSecret = &quot;8085ed1d1fc7739e9e058d2ad7fbb881&quot;</div><div class="line">let aliyunpush_messageNoti = &quot;CCPDidReceiveMessageNotification&quot;</div><div class="line"></div><div class="line">@UIApplicationMain</div><div class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</div><div class="line"></div><div class="line">    var window: UIWindow?</div><div class="line"></div><div class="line">    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool &#123;</div><div class="line">        // Override point for customization after application launch.</div><div class="line">        </div><div class="line">        //init aliyun Push SDK</div><div class="line">        initCloudPush(application: application)</div><div class="line">        </div><div class="line">        //feedback to aliyun server</div><div class="line">        CloudPushSDK.handleLaunching(launchOptions)</div><div class="line">        </div><div class="line">        return true</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>配置推送注册方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">func initCloudPush(application : UIApplication) &#123;</div><div class="line"></div><div class="line">        CloudPushSDK.asyncInit(aliyunpush_AppKey, appSecret: aliyunpush_AppSecret) &#123; (res) in</div><div class="line">            if (res?.success)! &#123;</div><div class="line">                print(&quot;Push SDK init success, deviceID: \(CloudPushSDK.getDeviceId())&quot;)</div><div class="line">            &#125;else&#123;</div><div class="line">                print(&quot;Push SDK init failed, error: \(res?.error?.localizedDescription)&quot;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //register APNS to fetch deviceToken</div><div class="line">        let settings = UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)</div><div class="line"></div><div class="line">        if #available(iOS 8.0, *) &#123;</div><div class="line">            </div><div class="line">            //iOS 8 notifications</div><div class="line">            </div><div class="line">            application.registerUserNotificationSettings(settings)</div><div class="line">            application.registerForRemoteNotifications()</div><div class="line">        &#125;else&#123;</div><div class="line">            </div><div class="line">            //iOS &lt; 8 Notifications</div><div class="line">            UIApplication.shared.registerUserNotificationSettings(settings)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        registerMessageReceive()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //APNS register success</div><div class="line">    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) &#123;</div><div class="line">        CloudPushSDK.registerDevice(deviceToken as Data!) &#123; (res) in</div><div class="line">            if (res?.success)!&#123;</div><div class="line">                print(&quot;Register deviceToken success&quot;)</div><div class="line">            &#125;else&#123;</div><div class="line">                print(&quot;Register deviceToken failed, error:\(res?.error?.localizedDescription)&quot;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //APNS register failed</div><div class="line">    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) &#123;</div><div class="line">        print(&quot;did fail to register for remote notification with error : \(error.localizedDescription)&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>推送处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//Observer remote Notifications - Background Mode &amp; Inactive Mode</div><div class="line">   func registerMessageReceive()   &#123;</div><div class="line">       NotificationCenter.default.addObserver(self, selector: Selector((&quot;onMessageReceived&quot;)), name: NSNotification.Name(rawValue: aliyunpush_messageNoti), object: nil)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //Handle remote Notifications - Background Mode &amp; Inactive Mode</div><div class="line">   func onMessageReceived(notification: NSNotification)  &#123;</div><div class="line">       let message : CCPSysMessage = notification.object as! CCPSysMessage</div><div class="line">       let title : NSString = NSString(data: message.title, encoding: String.Encoding.utf8.rawValue)!</div><div class="line">       let body : NSString = NSString(data: message.title, encoding: String.Encoding.utf8.rawValue)!</div><div class="line">       print(&quot;Received Message title: \(title), content:\(body)&quot;)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //Observer &amp; Handle remote Notifications - Foreground Mode</div><div class="line">   func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) &#123;</div><div class="line">       print(&quot;REceive one notification.&quot;)</div><div class="line">       </div><div class="line">       //retreive APNS content</div><div class="line">       </div><div class="line">       let aps_dic : NSDictionary = userInfo[&quot;aps&quot;] as! NSDictionary</div><div class="line">       </div><div class="line">       //content</div><div class="line">       let content = aps_dic.value(forKey: &quot;alert&quot;)</div><div class="line">       </div><div class="line">       //barge num</div><div class="line">       let badge = (aps_dic.value(forKey: &quot;badge&quot;) as AnyObject).integerValue</div><div class="line">       </div><div class="line">       //sound</div><div class="line">       let sound = aps_dic.value(forKey: &quot;sound&quot;)</div><div class="line">       </div><div class="line">       //extras</div><div class="line">       let extras = aps_dic.value(forKey: &quot;Extras&quot;)</div><div class="line">       </div><div class="line">       print(&quot;content: \(content)\n, badge:\(badge)\n, sound :\(sound)\n, Extras: \(extras)&quot;)</div><div class="line">       </div><div class="line">       application.applicationIconBadgeNumber = 0</div><div class="line">       </div><div class="line">       CloudPushSDK.handleReceiveRemoteNotification(userInfo)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>最后运行程序，看到如下结果就可以去交任务啦。</p>
<p><img src="https://cl.ly/hQrt/aliyun_8.png" alt=""></p>
<p>完结，鼓掌，撒花～～</p>
<p><img src="https://cl.ly/hQsX/PrettyGood.png" alt=""></p>
<hr>
<p>This artical is avaliable under <a href="http://wtfpl2.com" target="_blank" rel="external">WTFPL-V2</a>. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - <a href="https://millionaryearl.github.io">Chen’s Alchemy</a> would be appreciated</p>
<hr>
<p>本文链接：<a href="https://millionaryearl.github.io/2016/09/01/swift-APNS-aliyun/">https://millionaryearl.github.io/2016/09/01/swift-APNS-aliyun/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新项目里的消息推送功能，公司技术部开会讨论后决定让 极光，百度，aws都歇菜，取而代之的是尝试 使用阿里云推送SDK。所以今天就简单记录下调试过程。&lt;br&gt;&lt;strong&gt;&lt;em&gt;新任务获得：使用阿里云推送SDK实现消息推送功能～&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="APNS" scheme="https://millionaryearl.github.io/categories/APNS/"/>
    
    
      <category term="Swift" scheme="https://millionaryearl.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
