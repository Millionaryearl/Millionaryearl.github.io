<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Crawl Web Content - 详解爬虫特殊场景语法</title>
      <link href="/2019/03/08/python-Scrapy-parser-addon/"/>
      <url>/2019/03/08/python-Scrapy-parser-addon/</url>
      <content type="html"><![CDATA[<p>好些没写点啥了。最近在爬取一些数据的时候，发现Y结构挺复杂的啊，各种tag中套tag，目标内容各种被tag隔断，甚至有些内容要在load more网络请求后才能出现，简直口怕。所以今天就记录一些颇具代表性的case，以备后用。<br><strong><em>新任务获得：详解部分特殊场景下的爬取逻辑</em></strong></p><a id="more"></a><h2 id="拼接Key值与使用变量值-s"><a href="#拼接Key值与使用变量值-s" class="headerlink" title="拼接Key值与使用变量值 - %s %()"></a>拼接Key值与使用变量值 - %s %()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;contson&quot; id=&quot;contsoneae647c5c110&quot;&gt;</span><br><span class="line">单车欲问边，属国过居延。</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">征蓬出汉塞，归雁入胡天。</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">大漠孤烟直，长河落日圆。</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">萧关逢候骑，都护在燕然。</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>目标是全取诗句内容，通过id属性，但这个值是contson + 一个变量动态构成的，所以需要拼接。同时在使用这个拼接后的变量时，写法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content_id = &apos;contson&apos;+item_id</span><br><span class="line">content_xpath = &quot;div[@id=&apos;%s&apos;]/text()&quot; %(content_id)</span><br><span class="line">item[&apos;content&apos;] = content.xpath(content_xpath).extract()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;content&apos;: [&apos;\n单车欲问边，属国过居延。&apos;,</span><br><span class="line">             &apos;征蓬出汉塞，归雁入胡天。&apos;,</span><br><span class="line">             &apos;大漠孤烟直，长河落日圆。&apos;,</span><br><span class="line">             &apos;萧关逢候骑，都护在燕然。\n&apos;]</span><br></pre></td></tr></table></figure><h2 id="不含有某属性-not"><a href="#不含有某属性-not" class="headerlink" title="不含有某属性 - not"></a>不含有某属性 - not</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;sonspic&quot;&gt;</span><br><span class="line">&lt;div class=&quot;cont&quot; style=&quot;margin-top:13px;&quot;&gt;</span><br><span class="line">&lt;div class=&quot;divimg&quot; style=&quot;margin-top:2px;&quot;&gt;</span><br><span class="line">&lt;a href=&quot;/authorv_52fceee85532.aspx&quot;&gt;&lt;img src=&quot;https://img.gushiwen.org/authorImg/wangwei.jpg&quot; width=&quot;105&quot; height=&quot;150&quot; alt=&quot;王维&quot;/&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p style=&quot;height:22px;&quot;&gt;</span><br><span class="line">&lt;a style=&quot;font-size:18px; line-height:22px; height:22px;&quot; href=&quot;/authorv_52fceee85532.aspx&quot;&gt;&lt;b&gt;王维&lt;/b&gt;&lt;/a&gt;</span><br><span class="line">&lt;a style=&quot;margin-left:5px;&quot; href=&quot;javascript:PlayAuthor(515)&quot;&gt;&lt;img id=&quot;speakerimgAuthor515&quot; src=&quot;/img/speaker.png&quot; / alt=&quot;&quot; width=&quot;16&quot; height=&quot;16&quot;/&gt;&lt;/a&gt;</span><br><span class="line">&lt;span id=&quot;authorPlay515&quot; style=&quot; display:none;width:1px; height:1px;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot; margin:0px;&quot;&gt;</span><br><span class="line">王维（701年－761年，一说699年—761年），字摩诘，汉族，河东蒲州（今山西运城）人，祖籍山西祁县，唐朝诗人，有“诗佛”之称。苏轼评价其：“味摩诘之诗，诗中有画；观摩诘之画，画中有诗。”开元九年（721年）中进士，任太乐丞。王维是盛唐诗人的代表，今存诗400余首，重要诗作有《相思》《山居秋暝》等。王维精通佛学，受禅宗影响很大。佛教有一部《维摩诘经》，是王维名和字的由来。王维诗书画都很有名，非常多才多艺，音乐也很精通。与孟浩然合称“王孟”。</span><br><span class="line">&lt;a href=&quot;/authors/authorvsw_52fceee85532A1.aspx&quot;&gt;► 446篇诗文&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>目标是获取到这块内容中的作者介绍模块内容。其位于第二个 &lt; p &gt; 中, 但讨厌的是其上还有个讨厌的 &lt; p &gt;, 怎么定位呢？找到所有的 &lt; p &gt;取第二个？根据特殊的style属性的值来找到第二个？都不靠谱，可以看到第一个&lt; p &gt;中包含一个&lt; span &gt;，但目标 &lt; P &gt;中是没有的，所以如下取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item[&apos;authorDetail&apos;] = authorReltated.xpath(&quot;p[not(span)]/text()&quot;).extract()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;authorDetail&apos;: [&apos;王维（701年－761年，一说699年—761年），字摩诘，汉族，河东蒲州（今山西运城）人，祖籍山西祁县，唐朝诗人，有“诗佛”之称。苏轼评价其：“味摩诘之诗，诗中有画；。王维精通佛学，受禅宗影响很大。佛教有一部《维摩诘经》，是王维名和字的由来。王维诗书画都很有名，非常多才多艺，音乐也很精通。与孟浩然合称“王孟”。&apos;]</span><br></pre></td></tr></table></figure><h2 id="load-more-网络请求"><a href="#load-more-网络请求" class="headerlink" title="load more - 网络请求"></a>load more - 网络请求</h2><p>经常网页上需要点击一下load more然后再能显示更多内容么。这个流程肢解开来就是，你在点的时候，发送了一个网络请求，而后根据response内容做动态渲染。所以如下处理</p><h3 id="查看网络请求"><a href="#查看网络请求" class="headerlink" title="查看网络请求"></a>查看网络请求</h3><ol><li>打开浏览器「检查元素」</li><li>切换到「网络」一栏</li><li>点击 「load more」 触发网络请求</li></ol><p>这里我们可以看到具体的细节了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">摘要</span><br><span class="line">URL: https://so.gushiwen.org/shiwen2017/ajaxshiwencont.aspx?id=eae647c5c110&amp;value=yi</span><br><span class="line">状态: 200</span><br><span class="line">来源: 网络</span><br><span class="line">地址: 223.111.239.88:443</span><br><span class="line"></span><br><span class="line">请求</span><br><span class="line">:method: GET</span><br><span class="line">:scheme: https</span><br><span class="line">:authority: so.gushiwen.org</span><br><span class="line">:path: /shiwen2017/ajaxshiwencont.aspx?id=eae647c5c110&amp;value=yi</span><br><span class="line">Cookie: Hm_lpvt_04660099568f561a75456483228a9516=1552025928; ASP.NET_SessionId=5vbb1cxxl5lectozzgalmwyb; Hm_lvt_04660099568f561a75456483228a9516=1551419804,1551665879,1551924009,1552025928</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: br, gzip, deflate</span><br><span class="line">Host: so.gushiwen.org</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15</span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Referer: https://so.gushiwen.org/shiwenv_eae647c5c110.aspx</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">响应</span><br><span class="line">:status: 200</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Set-Cookie: sec_tc=AQAAAAgAOWBM0AYAdYNoEC8xgGUPsd89; Path=/; Expires=Fri, 08-Mar-19 07:23:36 GMT; HttpOnly</span><br><span class="line">Via: cache2.l2st4-4[48,200-0,M], cache9.l2st4-4[49,0], skunlun7.cn1418[0,200-0,H], skunlun9.cn1418[1,0]</span><br><span class="line">Age: 5696</span><br><span class="line">Expires: Fri, 08 Mar 2019 07:38:41 GMT</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">Cache-Control: public, max-age=7200</span><br><span class="line">Date: Fri, 08 Mar 2019 05:38:40 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Vary: Accept-Encoding, *</span><br><span class="line">Last-Modified: Fri, 08 Mar 2019 05:38:41 GMT</span><br><span class="line">x-swift-savetime: Fri, 08 Mar 2019 05:38:41 GMT</span><br><span class="line">x-aspnet-version: 4.0.30319</span><br><span class="line">x-cache: HIT TCP_MEM_HIT dirn:-2:-2</span><br><span class="line">x-powered-by: UrlRewriter.NET 1.7.0, ASP.NET</span><br><span class="line">Server: Tengine</span><br><span class="line">ali-swift-global-savetime: 1552023521</span><br><span class="line">x-swift-cachetime: 7200</span><br><span class="line">eagleid: df6fef1d15520292164464124e</span><br><span class="line"></span><br><span class="line">查询字符串参数</span><br><span class="line">id: eae647c5c110</span><br><span class="line">value: zhu</span><br></pre></td></tr></table></figure><h3 id="模拟发送请求"><a href="#模拟发送请求" class="headerlink" title="模拟发送请求"></a>模拟发送请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req_url = &apos;https://so.gushiwen.org/shiwen2017/ajaxshiwencont.aspx?id=%s&amp;value=yi&apos;</span><br><span class="line">request_translation = scrapy.Request(req_url%item_id, callback=self.parse_translation, dont_filter=True)</span><br><span class="line">request_translation.meta[&apos;item&apos;] = item</span><br><span class="line">request_translation.meta[&apos;item_id&apos;] = item_id</span><br><span class="line">yield request_translation</span><br></pre></td></tr></table></figure><p>解读</p><ol><li>拼接url</li><li>建立request</li><li>申明这个request的回调函数为「parse_translation」方法，「dont_filter」设置为True是为了防止因为 「requestUrl」被「allowed_domain」给过滤掉了导致请求失败</li><li>把之前处理好的数据，塞入「request.meta」中带到callback方法中</li><li>同上</li><li>递归callback回传的值作为return值</li></ol><p>之后就可以在callback方法里继续解析啦</p><h2 id="琐碎信息聚合"><a href="#琐碎信息聚合" class="headerlink" title="琐碎信息聚合 -"></a>琐碎信息聚合 -</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">征蓬出汉塞</span><br><span class="line">   &lt;span style=&quot;color:#286345;&quot;&gt;(sài)&lt;/span&gt;，归雁</span><br><span class="line">   &lt;span style=&quot;color:#286345;&quot;&gt;(yàn)&lt;/span&gt;入胡天。</span><br><span class="line">   &lt;br /&gt;</span><br><span class="line">   &lt;span style=&quot;color:#286345;&quot;&gt;征蓬：随风飘飞的蓬草，此处为诗人自喻。归雁：雁是候鸟，春天北飞，秋天南行，这里是指大雁北飞。胡天：胡人的领空。这里是指唐军占领的北方地方。&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>这里我们可以看到目标信息，有的是直接作为 &lt; p &gt; 的内容存在的，有的是被塞到 &lt; span &gt; 中的，比较琐碎，需要聚合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a_raw = response.xpath(&quot;//p[not (@style)]&quot;)</span><br><span class="line">for a_raw_p in a_raw:</span><br><span class="line">a_raw_contents = a_raw_p.xpath(&quot;normalize-space()&quot;).extract()</span><br><span class="line">print(a_raw_contents)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;征蓬出汉塞(sài)，归雁(yàn)入胡天。征蓬：随风飘飞的蓬草，此处为诗人自喻。归雁：雁是候鸟，春天北飞，秋天南行，这里是指大雁北飞。胡天：胡人的领空。这里是指唐军占领的北方地方。&apos;]</span><br></pre></td></tr></table></figure><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>未完待续。。。<br><img src="https://cl.ly/303L2K1N1R1N/comic-gogogo.png" alt=""></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2019/03/08/python-Scrapy-parser-addon/">http://yoursite.com/2019/03/08/python-Scrapy-parser-addon/</a></p>]]></content>
      
      <categories>
          
          <category> Scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift Notes - iOS10下的Client端APNS实现（基本）</title>
      <link href="/2017/05/04/swift-APNS-iOS10/"/>
      <url>/2017/05/04/swift-APNS-iOS10/</url>
      <content type="html"><![CDATA[<p>一晃都 <code>iOS</code> 都到版本10了(明明都10好久了好吧),按照苹果公司没事儿就要搞个大新闻的尿性，肯定又是一大堆的类被精炼，一大堆的方法被废弃，这不到 <code>iOS10</code>了，APNS就倒了霉了(<strong>UserNotifications 库</strong> 被引入以全盘接管苹果消息推送服务)，各种方法被废弃，导致了作者被测试组同事疯狂骚扰，无限报bug（什么坐着收不到通知啦，躺着也收不到啦，什么badge number不对啊。。。）。 于是作者就给掰扯掰扯，就当抛砖了。<br><strong><em>新任务获得：升级APNS前端代码以支持全版本下的消息推送需求</em></strong></p><a id="more"></a><h2 id="消息推送需求肢解"><a href="#消息推送需求肢解" class="headerlink" title="消息推送需求肢解"></a>消息推送需求肢解</h2><p>呐，基础的 <code>APNS</code> 组成部件和流程你们肯定都懂，不懂得就随便去网上找下吧解说的不要太多；然后那些证书啊，APP Key啊的配置估计你们也都知道，不知道的可以看下我写的第一篇博客里除了前端代码的那一部分<a href="https://millionaryearl.github.io/2016/09/01/swift-APNS-aliyun/" target="_blank" rel="noopener">Swift Notes - 阿里云推送SDK配置</a>，当然如果你选用的是其他服务器比如极光，百度之类的，也可以凑合看下，毕竟只是sdk换了下。</p><p>那回到前端，我们要的活儿有哪些呢</p><ol><li>先是注册设备 – （把 <code>deviceId</code> 发送给<code>推送服务器</code>，得到 <code>push token</code>作为设备标识以供<code>苹果通知服务器</code>定向推送消息）</li><li>注册请求成功/失败的处理 – （没啥大用，就是成功了么就把 <code>push token</code> 打出来看下，失败了么就把错误信息打出来看看原因）</li><li><p>那注册完了么自然就是收到通知后的处理了 – （这里我们仅处理标准通知，威力加强版的我们到时候再说，可能下期吧）</p><p>那明确了需求细节之后么，我就开始吧<br><img src="https://cl.ly/303L2K1N1R1N/comic-gogogo.png" alt="2"></p></li></ol><h2 id="注册设备"><a href="#注册设备" class="headerlink" title="注册设备"></a>注册设备</h2><p>如上所诉，这里的注册有两部，一步启动<code>推送SDK</code>完成初始化；另一步与<code>苹果通知服务器</code>交互完成初始化</p><h3 id="与推送SDK初始"><a href="#与推送SDK初始" class="headerlink" title="与推送SDK初始"></a>与<code>推送SDK</code>初始</h3><p>这个还是和跳的推送服务器有关的，毕竟每家的接口不一样么，详细的和推送服务器初始化交互的接口怎么用，各家SDK肯定都有教程的，这个需要看官们找一下，我这就以<code>阿里云</code>的为例了</p><pre><code>// init Aliyun Push SDKfunc initCloudPushSDK() {    CloudPushSDK.asyncInit(testAppKey, appSecret: testAppSecret) { (res) in        if (res!.success) {            print(&quot;Push SDK init success, deviceId: \(CloudPushSDK.getDeviceId()!)&quot;)        } else {            print(&quot;Push SDK init failed, error: \(res!.error!).&quot;)        }    }}</code></pre><h3 id="与苹果通知服务器交互"><a href="#与苹果通知服务器交互" class="headerlink" title="与苹果通知服务器交互"></a>与<code>苹果通知服务器</code>交互</h3><p>那原本的注册代码只要针对 <code>iOS8</code>以下和<code>iOS8</code>以上，写两套代码的(<code>iOS8</code>时苹果公司也搞了个大新闻)，那现在引入了 <code>UserNotifications Framework</code>, 我们需要现在<code>AppDelegate</code>文件里引入这个库文件</p><pre><code>import UIKit// iOS 10+ notificaitonimport UserNotifications@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate {</code></pre><p>然后把<code>iOS8</code>以上版本代码进一步分化为<code>iOS8-10</code>之间和<code>iOS10</code>以上两套代码，总计三套代码如下：</p><pre><code>// Register APNS, fetch deviceToen for pushing notificationsfunc registerAPNs(_ application: UIApplication) {    if #available(iOS 10, *) {        // iOS 10+        let center = UNUserNotificationCenter.current()        center.delegate = self        // request User authorization        center.requestAuthorization(options: [.alert, .badge, .sound], completionHandler: { (granted, error) in            if (granted) {                // User authored notification                print(&quot;User authored notification.&quot;)                // Real register to APNS, after user does authorize                application.registerForRemoteNotifications()            } else {                // User denied notification                print(&quot;User denied notification.&quot;)            }        })    } else if #available(iOS 8, *) {        // iOS 8+        application.registerUserNotificationSettings(UIUserNotificationSettings.init(types: [.alert, .badge, .sound], categories: nil))        application.registerForRemoteNotifications()    } else {        // &lt; iOS 8        application.registerForRemoteNotifications(matching: [.alert,.badge,.sound])    }}</code></pre><h2 id="注册设备成功／失败回调"><a href="#注册设备成功／失败回调" class="headerlink" title="注册设备成功／失败回调"></a>注册设备成功／失败回调</h2><p>呃，这块貌似没啥好说的了，直接上代码吧</p><pre><code>//APNS register successfunc application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {    CloudPushSDK.registerDevice(deviceToken as Data!) { (res) in        if (res?.success)!{            print(&quot;Register deviceToken success&quot;)            print(&quot;token\(CloudPushSDK.getApnsDeviceToken())&quot;)        }else{            print(&quot;Register deviceToken failed, error:\(res?.error?.localizedDescription)&quot;)        }    }}//APNS register failedfunc application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {    print(&quot;did fail to register for remote notification with error : \(error.localizedDescription)&quot;)}</code></pre><h2 id="处理收到的通知"><a href="#处理收到的通知" class="headerlink" title="处理收到的通知"></a>处理收到的通知</h2><p>根据前端app所处的状态，我们需要处理三种状态下的通知：<code>Foreground mode</code> <code>Background mode</code> <code>Inactive mode</code></p><h3 id="Foreground-Mode"><a href="#Foreground-Mode" class="headerlink" title="Foreground Mode"></a>Foreground Mode</h3><p>这种模式是app正在前端运行中的状态，设备顶部不会有通知栏出现，所以不会有通知栏手势响应的情况，更多的时候我们是以此触发一些内部逻辑（动画啊，页面跳转什么的），那在<code>iOS10</code>以前，是如下处理的：<br><strong><em>注：即便app处于前台，iOS10以后，通知栏也会出现，手势响应同Background Mode(第二段代码)</em></strong></p><pre><code>    //Handle remote Notifications - Foreground Mode (iOS &lt; 10)func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) {    print(&quot;REceive one notification.&quot;)    if application.applicationState == UIApplicationState.active{        ...Your logic...        ...Foreground Mode...    }}</code></pre><p>如上所说，<code>iOS10</code>引入了<code>UserNotification Framework</code>，自然这个新的库会提供新的方法咯，如下：</p><pre><code>//Handle remote Notifications - Foreground Mode (iOS 10+)@available(iOS 10.0, *)func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {    print(&quot;Receive a notification in foreground.&quot;)    ...Your logic...    ...Foreground Mode...    // hide alert    completionHandler([])    // show alert with popup,badge,sound    //completionHandler([.alert, .badge, .sound])}</code></pre><h3 id="Background-Mode"><a href="#Background-Mode" class="headerlink" title="Background Mode"></a>Background Mode</h3><p>那这种模式是app依然在运行，只不过是在后台挂起的状态，应该是通知推送最常遇到的场景了，会有顶部弹出，以及通知栏手势响应. 这种模式下的响应函数与<code>Foreground Mode</code>的一样，只不过通过<code>application.status</code>属性进行区分。在<code>iOS10</code>以前，是如下处理的：</p><pre><code>//Handle remote Notifications - Foreground Mode (iOS &lt; 10)func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) {    print(&quot;REceive one notification.&quot;)    if application.applicationState == UIApplicationState.active{        ...Your logic...        ...Foreground Mode...    }else{        ...Your logic...        ...Background Mode...    }}</code></pre><p>但<code>iOS10 UserNotifications Framework</code> 被引入以后，上面的代码就瞎了。。。不会被调用，也没有新的替换方法(作者就是个废物啊，确实没研究出来，有知道的看官请告诉我). 但实际上问题也不大啦，毕竟<code>Background Mode</code>下你也没有太多的内部逻辑可动，而且具体的通知手势响应回调函数，<code>UserNotifications Framework</code> 还是厚道的提供了的，如下：</p><pre><code>// Handle remote Notifications action(Click/Delete/Self-defined actions) //- Foreground &amp; Background Mode (iOS 10+)@available(iOS 10, *)func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {    if UIApplication.shared.applicationState.applicationState == UIApplicationState.active{        ...Your logic...        ...Foreground Mode...    }else{        let userAction = response.actionIdentifier        if userAction == UNNotificationDefaultActionIdentifier {        print(&quot;User opened the notification.&quot;)            ...Your logic...            ...Background Mode...          }         if userAction == UNNotificationDismissActionIdentifier {            print(&quot;User dismissed the notification.&quot;)        }      }            completionHandler()}</code></pre><h3 id="Inactive-Mode"><a href="#Inactive-Mode" class="headerlink" title="Inactive Mode"></a>Inactive Mode</h3><p>这种模式是app已经被杀掉的状态（挂起过长被动杀掉，手动杀掉），会有顶部通知栏，有通知手势响应。与<code>Foreground Mode</code>和<code>Background Mode</code>不同的是，这种模式走的<code>application: didFinishLaunchingWithOptions</code>方法，而且<code>所有的iOS版本</code>都只有一套代码如下：</p><pre><code>//Handle remote Notifications//- Inactive Mode (iOS all version)func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {    if launchOptions != nil {        let option = launchOptions![UIApplicationLaunchOptionsKey.remoteNotification] as? NSDictionary        if option != nil {           ...Your logic...           ...Inactive Mode...        }    }}</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="角标的问题"><a href="#角标的问题" class="headerlink" title="角标的问题"></a>角标的问题</h3><p>大多数时候呢，通知的角标数量都是由后台通过<code>通知内容(Notification Payload)</code>里的<code>Badge</code>字段配置的，前端只是由系统自动的简单的响应下。当然你也可以在适当的地方通过如下代码手动管理：</p><pre><code>UIApplication.shared.applicationIconBadgeNumber = 99</code></pre><p>这里有的看客可能会问了，那app在<code>Inactive Mode</code>甚至<code>Background Mode</code>下基本无发运行代码，怎么会更新角标(包括播放音乐)？这里同样要求你后端的同事通过将<code>通知内容(Notification Payload)</code>里的<code>Content-avaiable</code>字段配置为<code>1</code>，这样设备就会在收到通知时短暂运行一下app，以实现更新。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>前文有提过新版本下的通知可以玩的花活儿越来越多了，主要有如下两支，至于具体怎么使用呢，我们下回再说（让作者先研究研究）</p><ul><li>自定义通知行为(Actionable Notification)</li><li>通知拓展(Notification Extension)</li></ul><p><img src="https://cl.ly/3g19313C0L0k/comic-dance.gif" alt="3"></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2017/05/04/swift-APNS-iOS10/">http://yoursite.com/2017/05/04/swift-APNS-iOS10/</a></p>]]></content>
      
      <categories>
          
          <category> APNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Build Your Own Blog - 被搜索引擎搜索到(Baidu)</title>
      <link href="/2017/04/28/hexo-Blog-SEO2/"/>
      <url>/2017/04/28/hexo-Blog-SEO2/</url>
      <content type="html"><![CDATA[<p>过了这么几个月，感觉纯走google搜索引擎的话，这个博客流量也忒低了，不利于作者装逼（当然也有可能是因为写的确实太烂了）。 所以么这就准备把 <code>无法被baidu搜索引擎抓取</code> 的问题给解决下。<br><strong><em>新任务获得：升级部署配置，以允许Baidu搜索</em></strong></p><a id="more"></a><h2 id="为啥百度搜不到"><a href="#为啥百度搜不到" class="headerlink" title="为啥百度搜不到"></a>为啥百度搜不到</h2><p>还能为啥，因为百度抓取频率太牛X，Github服务器受不鸟咧，就把百度抓取给禁止了，一了百了，根治。 于是我们的Github-Pages就悲剧了。</p><p><img src="https://cl.ly/0I0b2L3v073r/comic-YaoMing.png" alt=""></p><p>那既然百度直接抓不到，我们就需要迂回一下了:</p><ul><li>让Github解放Baidu抓取权限（然而你并不能）</li><li>使用CDN加速，这样Baidu就可以迂回抓取了（然后需要付费）</li><li><u>部署内容镜像，Baidu就可以通过镜像迂回抓取了</u></li></ul><h2 id="部署镜像"><a href="#部署镜像" class="headerlink" title="部署镜像"></a>部署镜像</h2><h3 id="挑选镜像-Coding-net"><a href="#挑选镜像-Coding-net" class="headerlink" title="挑选镜像 - Coding.net"></a>挑选镜像 - Coding.net</h3><p>理论上来说呢，Hexo可以配套部署的类型有:</p><ul><li><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">git</a></li><li><a href="https://github.com/hexojs/hexo-deployer-heroku" target="_blank" rel="noopener">Heroku</a></li><li><a href="https://github.com/hexojs/hexo-deployer-rsync" target="_blank" rel="noopener">Rsync</a></li><li><a href="https://github.com/hexojs/hexo-deployer-openshift" target="_blank" rel="noopener">OpenShift</a></li><li><a href="https://github.com/hexojs/hexo-deployer-ftpsync" target="_blank" rel="noopener">FTPSync</a></li><li><a href="https://github.com/lucascaro/hexo-deployer-sftp" target="_blank" rel="noopener">SFTP</a></li></ul><p>但这不是已经用的 <code>Github-Pages</code> 是属于 <code>git</code> 系的么，所以我们的镜像也挑个 <code>git</code> 系的得了 - <a href="https://coding.net" target="_blank" rel="noopener">Coding.net</a>. </p><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p> 那第一步自然就是注册账号了么。登录过后去创建一个<code>和用户名一样名称</code>的<code>公开</code>项目<br> <img src="https://cl.ly/3W0n2U0u2X3l/hexo-Blog-SEO2-1.png" alt="9"></p><h3 id="上传SSH公钥"><a href="#上传SSH公钥" class="headerlink" title="上传SSH公钥"></a>上传SSH公钥</h3><p>因为写完博客后，执行”hexo -d”部署静态文件时，需要和服务器通过SSH安全连接么，那自然我们需要把公钥先部署到镜像服务器上咯。</p><p>所以我们先要找到这对SSH key（你的Github肯定是部署过了的，不然每次都要输账号，再密码验证的。如果确实没有，想知道怎么生成，<a href="shttps://git-scm.com/book/zh/v1/服务器上的-Git-生成-SSH-公钥" target="_blank" rel="noopener">请正面上我</a>）。打开命令行，输入如下命令，其中的 <code>id_rsa.pub</code> 文件就是我们要找的公钥啦。</p><pre><code>$ cd ~/.ssh$ lsauthorized_keys2  id_rsa       known_hostsconfig            id_rsa.pub</code></pre><p>复制公钥内容，粘贴，添加，搞掂～<br><img src="https://cl.ly/3N3I2v1J2m0p/hexo-Blog-SEO2-2.png" alt="11"></p><h3 id="配置Hexo-config"><a href="#配置Hexo-config" class="headerlink" title="配置Hexo config"></a>配置Hexo config</h3><p>服务器端配置好了之后，我们就需要告诉 <code>Hexo</code> 除了 <code>Github-pages</code> 之外， 你还要多一个地址提交静态文件，那这个地址是啥呢，就是你新建的项目ssh地址，如图：<br><img src="https://cl.ly/3H073B341N2s/hexo-Blog-SEO2-3.png" alt="12"><br>然后找到工程目录下的 <code>_config.yml</code> 文件底部，添加一个新的 <code>repo:</code>, 如图：<br><img src="https://cl.ly/122t1L1B1G3J/hexo-Blog-SEO2-4.png" alt="13"></p><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>配置工作结束后，自然就是要试试效果了，打开项目路径下的命令行，输入：</p><pre><code>hexo cleanhexo d</code></pre><p>然后你可能会看到命令行问你要 <code>ssh口令</code> :</p><pre><code>INFO  Deploying: gitINFO  Clearing .deploy_git folder...INFO  Copying files from public folder...[master 8ff47ea] Site updated: 2017-05-04 10:20:41 6 files changed, 33 insertions(+), 25 deletions(-)Enter passphrase for key &apos;/Users/chenwei/.ssh/id_rsa&apos;: </code></pre><p>知道的话，那输入一下就好；不知道的么，如果你是 <code>windows/linux OS</code> 的话，貌似就只能重新生成 <code>SSH key</code>，然后上传 <code>Coding.net</code>了； 如果你是 <code>mac OS</code>的话，还可以抢救下，去到 <code>keychain.app</code> 里，搜索ssh,找到你使用的公钥，双击完,勾选 <code>显示密码</code>， 输入 <code>登陆密码</code>,就可以看到口令了.</p><p><img src="https://cl.ly/1C440F2p1h28/hexo-Blog-SEO2-5.png" alt="14"></p><h2 id="访问镜像"><a href="#访问镜像" class="headerlink" title="访问镜像"></a>访问镜像</h2><p>去到 <code>Coding.net</code> 网页上项目里的 <code>Pages 服务</code> 项目， 找到自己的镜像 <code>URL 地址</code>，点进去就可以看到你的镜像博客啦</p><p><img src="https://cl.ly/1D433Q2V0g11/hexo-Blog-SEO2-6.png" alt="15"></p><p>最后去到 <code>baidu.com</code> 搜索一下我们的博客名, 完美！泼费！奈斯！骨胶补！！！</p><p><img src="https://cl.ly/3Q3Q1g412i1z/hexo-Blog-SEO2-7%E5%89%AF%E6%9C%AC.png" alt="16"></p><h2 id="额外项目"><a href="#额外项目" class="headerlink" title="额外项目"></a>额外项目</h2><p>现在我们有了镜像，加上 <code>Github-pages</code>，实际上我们是有两个地址的， 虽然他们的内容是100%一样的，但总归是有点膈应不是，毕竟是两个访问地址(<code>URL</code>)么. 那有什么办法可以使用一个url，根据需要（国内走<code>Coding.net</code>，国外走 <code>Github-pages</code>）显示内容呢？</p><pre><code>解：自己买个域名，然后通过不同的cname解析，自动指向两个不同的url</code></pre><p>具体的方案么，因为买域名要花钱！！！作者就不实践了，啊哈哈哈（尴尬笑）。</p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2017/04/28/hexo-Blog-SEO2/">http://yoursite.com/2017/04/28/hexo-Blog-SEO2/</a></p>]]></content>
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift Notes - 便捷配置多环境服务器地址</title>
      <link href="/2017/02/10/swift-ProjectSet-agileServerUrl/"/>
      <url>/2017/02/10/swift-ProjectSet-agileServerUrl/</url>
      <content type="html"><![CDATA[<p>最近几个项目同时准备上线，几个项目的服务器地址不断在开发环境，测试环境，生产环境间切来切去，苦不堪言。探索一番之后，发现可以使用预编译宏结合工程配置后，通过“Edit Scheme”来简单实现，遂作此文以记录。<br><strong><em>新任务获得: 使用预编译宏结合“Edit Scheme”功能以快速切换服务器地址</em></strong></p><a id="more"></a><h2 id="手忙脚乱方案"><a href="#手忙脚乱方案" class="headerlink" title="手忙脚乱方案"></a>手忙脚乱方案</h2><p>这个么就是之前一直在用的傻缺方案。</p><pre><code>//dev enviromentlet serverlUrl = https://dev-serverUr...//test enviromentlet serverUrl = https://test-serverUr...//dist enviromentlet serverUrl = https://dist-serverUr...</code></pre><p>首先把服务器地址抽出来作全局变量；而后根据实际需求复制若干套，并赋予对应的值；最后用的时候么就保留对应的那一套，再注释掉剩余的配置。然后注释来注释去注着注着就晕了。。。</p><p><img src="https://cl.ly/0G001k0y0N2I/facepalm_picard.jpg" alt=""></p><h2 id="便捷方案"><a href="#便捷方案" class="headerlink" title="便捷方案"></a>便捷方案</h2><p>看看炼成书，查阅 《便捷配置服务器地址》 项：<code>Preprocessor Macro ＋ Project Configuration + Edit Scheme = 便捷配置服务器地址</code><br>这个方案的实际上是脱胎于上面那个方案，核心思想是优先运用预编译宏来划分开来各个环境下的服务器地址，再在工程配置文件中创建各环境的键并与对应的预编译宏关联，最后通过切换编译环境来实现服务器地址的替换</p><p><img src="https://cl.ly/083k2D3B1M36/swift-ProjectConfig-AgileServerUrl-1.png" alt=""></p><h3 id="预编译宏配置各环境下服务器地址"><a href="#预编译宏配置各环境下服务器地址" class="headerlink" title="预编译宏配置各环境下服务器地址"></a>预编译宏配置各环境下服务器地址</h3><p>类似于上面的傻缺方案，我们依然需要把服务器地址抽出来作全局变量；而后根据实际需求复制若干套，并赋予对应的值。只不过加入预编译宏来判断各个环境下服务器地址该取那一段的值。</p><pre><code>#if DEVlet serverlUrl = https://dev-serverUr。。。#elseif TESTlet serverUrl = https://test-serverUr。。。#elseif DISTlet serverUrl = https://dist-serverUr。。。#else#endif</code></pre><p>上述代码就是申明了三个编译环境配置: DEV, TEST, DIST(这个名字随便取)。这里的三个编译环境配置，会作为预编译宏在下一步中用到。</p><h3 id="配置系统参数"><a href="#配置系统参数" class="headerlink" title="配置系统参数"></a>配置系统参数</h3><p>这里有两步，首先需要在项目文件中（projectName.xcodeproj）－ PROJECT栏中Info分区的Configuration块里建立对应环境的键</p><p><img src="https://cl.ly/2L003j1X1Y1s/swift-ProjectConfig-AgileServerUrl-2.png" alt=""></p><p>第二步就是把对应环境的键与第一项中自定义的预编译宏匹配上</p><p><img src="https://cl.ly/200I0U0M3k3r/swift-ProjectConfig-AgileServerUrl-3.png" alt=""></p><p><img src="https://cl.ly/2P0U0r1W2A0t/swift-ProjectConfig-AgileServerUrl-4.png" alt=""></p><h3 id="调整运行参数"><a href="#调整运行参数" class="headerlink" title="调整运行参数"></a>调整运行参数</h3><p>全部配置好了之后，可以在<code>Edit Scheme</code>中选择需要的配置以达到快速更换服务器地址的目的</p><p><img src="https://cl.ly/3p1I3E0o3i1c/swift-ProjectConfig-AgileServerUrl-5.png" alt=""></p><h2 id="方便的改些其他玩意儿？"><a href="#方便的改些其他玩意儿？" class="headerlink" title="方便的改些其他玩意儿？"></a>方便的改些其他玩意儿？</h2><p>现在我们有三个configuration: Debug, Dev, Release, 上面展示了我们如何快速的改变全局变量（服务器地址），那延展开了也许我们可以改些其他的玩意儿，比如App Name？ </p><h3 id="配置各环境下的App-Name"><a href="#配置各环境下的App-Name" class="headerlink" title="配置各环境下的App Name"></a>配置各环境下的App Name</h3><p>先在项目文件中（projectName.xcodeproj）－ TARGETS栏中Build Settings分区中找一找有没有对应的键，找到的么就设置下各configuration的值，例如 Asset Catalog App Icon Set Name － 应用图标</p><p><img src="https://cl.ly/162L1q2a3X0w/swift-ProjectConfig-AgileServerUrl-6.png" alt=""></p><p>那对于没找到的，我们可以点 Build Settings 里的 ＋ 号，添加一个 User-Defined Setting，然后同上一遍设置下各configuration的值</p><p><img src="https://cl.ly/2C2d0a0Q3m1U/swift-ProjectConfig-AgileServerUrl-7.png" alt=""></p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>通过在项目文件Info分区下建立各个环境的Configuration项，尔后配置各个Configuration项中的键值，最后在Scheme下使用不同的Configuration，就可以很方便的修改一些（全局变量）系统参数<br><img src="https://cl.ly/2o1B0p203K1V/comic-yay.jpg" alt=""></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2017/02/10/swift-ProjectSet-agileServerUrl/">http://yoursite.com/2017/02/10/swift-ProjectSet-agileServerUrl/</a></p>]]></content>
      
      <categories>
          
          <category> Project-Config </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Crawl Web Content - 粗解爬虫解析流程及结果输出</title>
      <link href="/2016/10/09/python-Scrapy-parser/"/>
      <url>/2016/10/09/python-Scrapy-parser/</url>
      <content type="html"><![CDATA[<p>通过上一篇博客的工作，我们拥有了一个简单爬虫。但确实有点简陋的过分了，要啥啥没有，所以今天主要就是简单讲解一下爬虫的解析流程与爬取结果的输出形式。<br><strong><em>新任务获得：粗解爬虫解析流程并设置爬取结果的输出</em></strong></p><a id="more"></a><h2 id="抓取流程"><a href="#抓取流程" class="headerlink" title="抓取流程"></a>抓取流程</h2><p><img src="https://cl.ly/3h3F0j1d1P0s/python_2_1.png" alt=""><br>实际上爬虫的工作流程很是直白的。首先找到包含目标信息的网站的网址，写入爬虫文件的<code>start_urls</code>参数，做为爬取的起始点。同时输入适当的网址到<code>allowed_domains</code>参数，来约束爬取的范围。</p><p>第二步是爬取到网站内容，这个内容基本上会以<code>HTML&amp;CSS</code>格式呈现，这一步<code>scrapy</code>会帮我们做的，通常我们只需要运行爬虫就可以了，应对一个复杂要求(例如：应对网站反爬取设置)可以在<code>/settings.py</code>文件里配置爬虫参数。感兴趣的可以<a href="https://doc.scrapy.org/en/latest/topics/settings.html" target="_blank" rel="noopener">正面上我</a></p><p>第三步是过滤抓取内容，以获得我们需要的信息。这个要求我们在运行爬虫之前制定好过滤规则，然后在运行爬虫时<code>scrapy</code>会直接使用</p><p>最后一步就是输出了，无论是直接以log形式在命令行里输出，还是保存到文件里，亦或是直接输入数据库都可以.</p><p>至此我们今天的任务就明确了，主要是讲解下在第三步和第四步要怎么做。<br><strong><em>任务更新：合理制定爬虫过滤规则与爬虫输出设置</em></strong></p><h2 id="制定爬虫过滤规则"><a href="#制定爬虫过滤规则" class="headerlink" title="制定爬虫过滤规则"></a>制定爬虫过滤规则</h2><p>因为每个抓取站点的h5文件结构都不一样，所以爬虫的可重用性比较低。对于不同的抓取目标，我们需要制定不同的抓取语句。一般的制定流程是先查阅目标站的H5结构，进而定制对应的抓取结构，最后编写抓取语句。</p><h3 id="查阅目标站点H5结构"><a href="#查阅目标站点H5结构" class="headerlink" title="查阅目标站点H5结构"></a>查阅目标站点H5结构</h3><ol><li><p>在命令行里查看<br> 使用<code>Scrapy</code>的<code>fetch</code>函数就可以直接现实H5文件结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy fetch http://www.biquge.tw/0_972/</span><br></pre></td></tr></table></figure></li><li><p>在浏览器里查看<br>这个么更直接，在浏览器里打开目标地址，然后进入开发者模式，显示网页源文件就可以看到了</p></li></ol><h3 id="定制抓取机制"><a href="#定制抓取机制" class="headerlink" title="定制抓取机制"></a>定制抓取机制</h3><p>这个么需要一定的H5和CSS基本知识，一点都不懂的可以去<a href="http://www.w3school.com.cn" target="_blank" rel="noopener">W3CSchool</a>上了解一下。例如我的目标信息是：小说章节的名称与链接地址。在刚才得到的H5结构文件里，查找对应的数据单元：</p><pre><code>&lt;dd&gt; &lt;a style=&quot;&quot; href=&quot;/0_972/4743476.html&quot;&gt;第一千五百九十五章 黑暗现象&lt;/a&gt;&lt;/dd&gt;</code></pre><p>可以看到我们需要的信息是存在于<code>&lt;dd&gt;&lt;/dd&gt;</code>标签内的一个<code>&lt;a&gt;</code>标签里的。所以我们需要的抓取机制应该是：</p><ul><li><strong>先筛选出所有的<code>&lt;dd&gt;&lt;/dd&gt;</code>标签</strong></li><li><strong>然后抓取之中的<code>&lt;a&gt;</code>标签下的<code>title</code>和<code>href</code>两个属性下的数据</strong></li></ul><p>那有人可能就会问了，明明我们需要的目标信息的最小标签单元是<code>&lt;a&gt;</code>标签,为什么要多此一举的先去筛选出上一级的<code>&lt;dd&gt;&lt;/dd&gt;</code>标签？那是因为网页里有很多其他的<code>&lt;a&gt;</code>标签，但它们的信息并非小说的章节信息，为了过滤掉这些合规却又不是有效信息的<code>&lt;a&gt;</code>标签内容，我们需要加入额外的筛选条件－上一级的<code>&lt;dd&gt;&lt;/dd&gt;</code>标签。</p><pre><code>&lt;li&gt;&lt;a href=&quot;/nweph.html&quot;&gt;排行榜单&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/quanben/&quot;&gt;完本小说&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a rel=&quot;nofollow&quot; href=&quot;/jilu.php&quot;&gt;阅读记录&lt;/a&gt;&lt;/li&gt;</code></pre><h3 id="编写抓取语句"><a href="#编写抓取语句" class="headerlink" title="编写抓取语句"></a>编写抓取语句</h3><p>这个抓取语句主要是写在爬虫文件中的”parse”函数里。这里我们打开<code>fiction/spiders/biquge.py</code>文件并编辑如下</p><pre><code># -*- coding: utf-8 -*-  from scrapy.spiders import Spiderfrom scrapy.selector import Selectorfrom fiction.items import FictionItemclass BiqugeSpider(Spider):    name = &quot;biquge&quot;    allowed_domains = [&quot;http://www.biquge.tw/&quot;]    start_urls = (        &apos;http://www.biquge.tw/0_972/&apos;,    )    def parse(self, response):        chapters = response.xpath(&apos;//dd&apos;)        items = []        for chapter in chapters:            item = FictionItem()            item[&apos;url&apos;] = chapter.xpath(                &apos;a/@href&apos;).extract()            item[&apos;title&apos;] = chapter.xpath(                &apos;a/text()&apos;).extract()            items.append(item)            print item[&apos;url&apos;], item[&apos;title&apos;]        return items</code></pre><p>上面的代码很好理解，前两行是引入相关的<code>scrapy</code>基础类，第三行是引入我们自定义的数据结构（具体信息可以去上篇博客里查看－定义模型）. 再下来么就是我们爬虫类<code>biqugeSpider</code>，头三行的爬虫属性设置也在上篇说过了，直接看到重点<code>parse</code>函数。</p><p>可以看到这个函数接收到了两个外部参数, <code>self</code> 和 <code>response</code>。<code>self</code>应该就是指爬虫自己，具体有啥用处，作者只能表示今天天气不错，啊哈哈哈。而<code>response</code>参数就是上述<code>抓取流程－第二步</code>抓取到全部网站内容，它应该是和上述<code>定制爬虫过滤规则－查阅目标站点H5结构</code>里看到的内容一致。</p><p>接下来就如上述<code>定制爬虫过滤规则－定制抓取机制</code>计划的一样，先过滤出所有的<code>&lt;dd&gt;&lt;/dd&gt;</code>标签内容，并建立一个空数组用以将来存储标签对象<code>Fiction</code>。再接下来建立一个<code>for</code>循环，从每段<code>&lt;dd&gt;&lt;/dd&gt;</code>标签内容里，进一步过滤出<code>url</code>和<code>title</code>字段信息，并存入新建的<code>Fiction</code>对象，加入到<code>items</code>结果数组里，同时在命令行里输出<code>url</code>和<code>title</code>结果。 最后在<code>for</code>循环结束后，返回<code>items</code>结果数组(这个暂时没有，稍后我们配置结果输出到json文件时会用到)</p><h3 id="数据提取机制"><a href="#数据提取机制" class="headerlink" title="数据提取机制"></a>数据提取机制</h3><p>虽然说知道了这段代码是怎么工作的，但具体怎么写不知道啊，到底怎么样才能从HTML源码中提取数据呢？其实有些库是可以做到的：</p><ul><li><a href="http://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">BeautifulSoup</a> 是在程序员间非常流行的网页分析库，它基于HTML代码的结构来构造一个Python对象， 对不良标记的处理也非常合理，但它有一个缺点：慢。<br>比如这些</li><li><a href="http://lxml.de/" target="_blank" rel="noopener">lxml</a> 是一个基于 <a href="http://docs.python.org/library/xml.etree.elementtree.html" target="_blank" rel="noopener">ElementTree</a> (不是Python标准库的一部分)的python化的XML解析库(也可以解析HTML)。</li></ul><p>但伟大的奥斯忒懦夫司机·作者曾经又说过</p><blockquote><p>作为一个菜鸡程序员，要有菜鸡程序员的尊严，坚决抵制听啊没听过的东西！</p></blockquote><p>所以有啥简单点的东西呢，找找看官网还真有－<code>Seletors</code>就可以完美替代，它是<code>Scrapy</code>自己提供的数据提取机制，可以通过特定的<code>XPath</code>和<code>CSS</code>表达式来选择 HTML文件中的某个部分。本篇作者就是用的这种提取机制，例如：</p><pre><code>response.xpath(&apos;//dd&apos;) //提取网页内容里的所有&lt;dd&gt;&lt;/dd&gt;标签内容...chapter.xpath(&apos;a/@href&apos;).extract() //提取chapther中&lt;a&gt;标签的@href属性chapter.xpath(&apos;a/text()&apos;).extract() //提取chapther中&lt;a&gt;标签的text值</code></pre><p>更多的<code>Seletor</code>提取讲解，可以<a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/topics/selectors.html#topics-selectors-ref" target="_blank" rel="noopener">正面上我</a></p><h2 id="设置爬虫输出设置"><a href="#设置爬虫输出设置" class="headerlink" title="设置爬虫输出设置"></a>设置爬虫输出设置</h2><p>至此我们的爬虫可以说已经是大功告成，但数据抓是抓到了，怎么输出来用呢。大概是有三个方向：</p><h3 id="直接以log形式在命令行里输出"><a href="#直接以log形式在命令行里输出" class="headerlink" title="直接以log形式在命令行里输出"></a>直接以log形式在命令行里输出</h3><p>这个最简单了，只要在爬虫文件里的<code>parse</code>函数里，使用<code>print</code>命令把相应的信息给打出来就可以了</p><pre><code>print item[&apos;url&apos;], item[&apos;title&apos;]</code></pre><h3 id="保存到文件里"><a href="#保存到文件里" class="headerlink" title="保存到文件里"></a>保存到文件里</h3><p>半自动的呢，可以在启动爬虫时，加入输出参数 <code>-o outputFileName</code>。需要注意的是<code>Scrapy</code>默认支持四种格式:<code>JSON</code>, <code>JSON lines</code>, <code>CSV</code>, <code>XML</code></p><pre><code>scrapy crawl fiction -o result.json // scrapy crawl spiderName -0 outputFileName</code></pre><p>正规一点的呢，需要修改<code>/pipelines.py</code>文件如下：</p><pre><code>import json  import codecs  import reclass FictionPipeline(object):def __init__(self):      self.file = codecs.open(&apos;cn_zhan.json&apos;, &apos;wb&apos;, encoding=&apos;utf-8&apos;) def process_item(self, item, spider):    if item[&apos;title&apos;]:        found = re.match(&apos;\S* \S*&apos;, str(item[&apos;title&apos;]))        if found:            print &apos;---------&apos;, item[&apos;title&apos;]            line = json.dumps(dict(item), ensure_ascii=False) + &quot;\n&quot;             self.file.write(line)               return item        else:            print &quot;+++++++++ invalid chapter found ++++++++++++++++&quot;def spider_closed(self, spider):    self.file.close()</code></pre><p>首先是在初始化方法里新建一个叫做<code>cn_zhan.json</code>的文件用以收纳抓取的信息，并约定它是<code>utf-8</code>格式（用来显示中文，同时打开它准备写入。第二步在<code>process_item</code>里我们根据正则表达式过滤掉不合规的<code>item</code>，并把合规的<code>item</code>（章节信息）转化成<code>json</code>语句存入之间申明的<code>cn_zhan.json</code>文件里。最后关闭这个文件。</p><p>定义好<code>/pipelines.py</code>文件后，我们还需要在<code>/settings.py</code>文件里启用刚定义的输送规则：</p><pre><code>ITEM_PIPELINES = {    #&apos;fiction.pipelines.DuplicatesPipeline&apos;: 100,    &apos;fiction.pipelines.FictionPipeline&apos;: 300,}</code></pre><p>注意在<code>/pipelines.py</code>文件里我们可以申明多个输送规则，例如这里作者还申明了一个去重原则。同时在<code>/settings.py</code>文件里启用时，<code>Scrapy</code>会依照数字从低到高的顺序，通过pipeline，通常将这些数字定义在0-1000范围内</p><h3 id="录入到数据库"><a href="#录入到数据库" class="headerlink" title="录入到数据库"></a>录入到数据库</h3><p>这个因为使用的数据库种类不同需要不同的配置，所以就先不讲解了，感兴趣的可以自己去狗哥一下</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>折腾了这么久，激动人心的时刻终于到来了，打开命令行开始运行爬虫，完成之后你就可以在你的文件夹里发现抓取的结果文件了:<code>cn_zhan.json</code></p><pre><code>{&quot;url&quot;: [&quot;/0_972/603364.html&quot;], &quot;title&quot;: [&quot;第一章 太阳消失&quot;]}{&quot;url&quot;: [&quot;/0_972/603365.html&quot;], &quot;title&quot;: [&quot;第二章 全球恐慌&quot;]}{&quot;url&quot;: [&quot;/0_972/603366.html&quot;], &quot;title&quot;: [&quot;第三章 黑暗时代&quot;]}{&quot;url&quot;: [&quot;/0_972/603367.html&quot;], &quot;title&quot;: [&quot;第四章 怪物降临&quot;]}...</code></pre><p>完美，破费，至此我们的爬虫应该可以说是初步成型了！诸君昌隆！<br><img src="https://cl.ly/3S1k1Z3k3q1i/comic_success_kid.jpg" alt=""></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2016/10/09/python-Scrapy-parser/">http://yoursite.com/2016/10/09/python-Scrapy-parser/</a></p>]]></content>
      
      <categories>
          
          <category> Scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Crawl Web Content - 环境搭配与基础爬虫</title>
      <link href="/2016/10/02/python-Scrapy-framework/"/>
      <url>/2016/10/02/python-Scrapy-framework/</url>
      <content type="html"><![CDATA[<p>写这篇博客呢，主要是为了响应之前打算自己搞个小说阅览App的想法。作为整个项目的一部分，我们需要自己利用爬虫工具去爬取网上的小说内容。<br><strong><em>新任务获得：制作爬虫并爬取网络内容</em></strong></p><a id="more"></a><p>打开炼成书，查询 网络爬虫 项目：<br><code>scrapy／ pyspider/ beautifulSoup = 爬虫</code><br>这三个都是比较成熟的python爬虫框架。<a href="https://scrapy.org/" target="_blank" rel="noopener">scrapy</a> 是其中最出名的，<a href="https://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">pyspider</a> 是个国人大神写的，<a href="https://github.com/binux/pyspider" target="_blank" rel="noopener">beautifulSoup</a> 老实说但就爬虫功能并不完整，主要是还能干点别的。至于你要是问作者为啥推荐的都是python的，php不能做爬虫么？那肯定是可以的啊，只不过作者太菜了，还无力使用世界上最伟大的语言好吧。<br><img src="https://cl.ly/0Q2e06242H0G/comic_hah.jpg" alt=""></p><p><strong><em>任务更新：使用Scrapy爬取网络内容</em></strong></p><h2 id="配置-Scrapy"><a href="#配置-Scrapy" class="headerlink" title="配置 Scrapy"></a>配置 Scrapy</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先我们肯定是把<code>Python</code>给安装一下的么，不会的伙计们请<a href="http://www.runoob.com/python/python-install.html" target="_blank" rel="noopener">正面上我</a>,在命令行里输入<code>python</code>，能看到如下就可以了</p><pre><code>Python 2.7.12 (default, Jun 29 2016, 14:05:02) [GCC 4.2.1 Compatible Apple LLVM 7.3.0 (clang-703.0.31)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; </code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>由于<code>Scrapy</code>需要 C 语言编译器及其开发前缀。 在 OSX 里这些都是由<code>Apple Xcode development tool</code>提供的， 在命令行里输入：</p><pre><code>$ xcode-select --install</code></pre><p>然后就是使用<code>pip</code>指令，安装<code>Scrapy</code>了，在命令行里输入：</p><pre><code>$ pip install Scrapy</code></pre><p>再输入<code>Scrapy</code>，能看到如下结果就可以了</p><pre><code>Scrapy 1.1.3 - no active projectUsage:    scrapy &lt;command&gt; [options] [args]...</code></pre><p>至此么，前期准备工作就都弄好了. 这里我们设定将要爬取的网络内容为这个<a href="http://www.biquge.tw/0_972/" target="_blank" rel="noopener">小说的章节目录信息</a>P.S.其他系统的安装教程请，<a href="http://scrapy.readthedocs.io/en/latest/intro/install.html" target="_blank" rel="noopener">正面上我</a><br><strong><em>任务更新：使用Scrapy爬取小说的章节目录信息</em></strong></p><h2 id="爬虫制作"><a href="#爬虫制作" class="headerlink" title="爬虫制作"></a>爬虫制作</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>伟大的奥斯忒懦夫司机·作者曾经说过</p><blockquote><p>在使用爬虫之前，你必须先拥有一个爬虫。而在拥有爬虫之前，你需要先有个放置爬虫的地方。</p></blockquote><p>所以我们需要先新建一个Scrapy项目。打开命令行，输入命令：</p><pre><code>$ scrapy startproject fiction</code></pre><p>输入命令<code>cd yourProjName</code>进入工程目录后，你就能看到自动创建的主体文件</p><ul><li><code>scrapy.cfg</code>： 项目的配置文件</li><li><code>fiction/</code>：项目的python模块。（我们代码工作主要在这里面）</li><li><code>fiction/items.py</code>： 定义抓取的模型</li><li><code>fiction/pipelines.py</code>： 模型管道文件.</li><li><code>fiction/settings.py</code>： 爬虫配置文件.</li><li><code>fiction/spiders/</code>： 放置爬虫代码的目录.</li></ul><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p><em>Item</em>是用于承载爬取到的数据的最小容器。和常规的ORM一样，你需要先创建一个<code>scrapy.Item</code>的类，然后定义你需要的类属性。比如对于小说的章节目录，我们需要知道每章的名字与链接地址，所以设定如下：</p><pre><code>from scrapy.item import Item, Fieldclass FictionItem(Item):    title = Field()    url = Field()</code></pre><h3 id="编写爬虫"><a href="#编写爬虫" class="headerlink" title="编写爬虫"></a>编写爬虫</h3><p>一个项目里可以拥有多个爬虫，输入命令<code>$ scrapy genspider -l</code> 我们就能看到<code>Scrapy</code> 提供给我们的四种基本的模版：</p><pre><code>Available templates:    basic    crawl    csvfeed    xmlfeed</code></pre><p>今次我们就直接使用<code>genspider</code>命令创建最基础的<code>basic</code>模版了，输入命令：</p><pre><code>scrapy genspider biquge www.biquge.tw//formulescrapy genspider -t crwal exmaple example.com</code></pre><p>这时候去到<code>/spiders</code>文件夹下，就可以看到这个名为<code>biquge</code>的爬虫文件了</p><pre><code># -*- coding: utf-8 -*-import scrapyclass biqugeSpider(scrapy.Spider):    name = &quot;biquge&quot;    allowed_domains = [&quot;http://www.biquge.tw/&quot;]    start_urls = (        &apos;http://www.biquge.tw/0_972/&apos;,    )    def parse(self, response):        pass</code></pre><p>打开爬虫文件，这里我们可以看到三个主要属性和一个主要方法：</p><ul><li>name : 爬虫的名字与唯一标识，不可以和其他爬虫重复，</li><li>allowed_domains : 允许爬取的域名</li><li>start_urls : 启动爬取的url列表</li><li>parse(): 解析抓到网页</li></ul><p>粘贴如下代码到<code>fiction/spiders/biquge.py</code>文件中：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> # -*- coding: utf-8 -*-  </span><br><span class="line"></span><br><span class="line">from scrapy.spiders import Spider</span><br><span class="line">from scrapy.selector import Selector</span><br><span class="line">from fiction.items import FictionItem</span><br><span class="line"></span><br><span class="line">class BiqugeSpider(Spider):</span><br><span class="line">    name = &quot;biquge&quot;</span><br><span class="line">    allowed_domains = [&quot;http://www.biquge.tw/&quot;]</span><br><span class="line">    start_urls = (</span><br><span class="line">        &apos;http://www.biquge.tw/0_972/&apos;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        chapters = response.xpath(&apos;//dd&apos;)</span><br><span class="line">        items = []</span><br><span class="line"></span><br><span class="line">        for chapter in chapters:</span><br><span class="line">            item = FictionItem()</span><br><span class="line">            item[&apos;url&apos;] = chapter.xpath(</span><br><span class="line">            &apos;a/@href&apos;).extract()</span><br><span class="line">            item[&apos;title&apos;] = chapter.xpath(</span><br><span class="line">            &apos;a/text()&apos;).extract()</span><br><span class="line">            items.append(item)</span><br><span class="line"></span><br><span class="line">            print item[&apos;url&apos;], item[&apos;title&apos;]</span><br><span class="line"></span><br><span class="line">        return items</span><br></pre></td></tr></table></figure><h3 id="开始爬取"><a href="#开始爬取" class="headerlink" title="开始爬取"></a>开始爬取</h3><p>终于可以开始爬数据了，在命令行里输入命令：</p><pre><code>$ scrapy crawl biquge -o result.json</code></pre><p><img src="https://cl.ly/0G3e1B16362x/comic_puke.gif" alt=""></p><p>命令行里你应该能看到如下的结果：</p><pre><code>2016-09-29 16:56:09 [scrapy] INFO: Scrapy 1.1.3 started (bot: fiction)2016-09-29 16:56:09 [scrapy] INFO: Optional features available: ...2016-09-29 16:56:09 [scrapy] INFO: Overridden settings: {}2016-09-29 16:56:09 [scrapy] INFO: Enabled extensions: ...2016-09-29 16:56:09 [scrapy] INFO: Enabled downloader middlewares: ...2016-09-29 16:56:09 [scrapy] INFO: Enabled spider middlewares: ...2016-09-29 16:56:09 [scrapy] INFO: Enabled item pipelines: ...2016-09-29 16:56:09 [scrapy] INFO: Spider opened...2016-09-29 16:56:09 [scrapy] INFO: Closing spider (finished)2016-09-29 16:56:16 [scrapy] INFO: Stored json feed (1622 items) in: result.json</code></pre><p>然后打开你的工作目录，你会发现多了一个<code>result.json</code>文件。打开该文件你就可以看到本次爬取的结果了－小说的章节目录：</p><pre><code>[{&quot;url&quot;: [&quot;/0_972/603364.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u4e00\u7ae0 \u592a\u9633\u6d88\u5931&quot;]},{&quot;url&quot;: [&quot;/0_972/603365.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u4e8c\u7ae0 \u5168\u7403\u6050\u614c&quot;]},{&quot;url&quot;: [&quot;/0_972/603366.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u4e09\u7ae0 \u9ed1\u6697\u65f6\u4ee3&quot;]},{&quot;url&quot;: [&quot;/0_972/603367.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u56db\u7ae0 \u602a\u7269\u964d\u4e34&quot;]},{&quot;url&quot;: [&quot;/0_972/603368.html&quot;], &quot;title&quot;: [&quot;\u7b2c\u4e94\u7ae0 \u602a\u7269\u9000\u907f&quot;]},...</code></pre><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>呃，总体上来说这个基础爬虫就算是完成了，虽然说有一大堆问题，什么章节名乱码啊，爬取数据的解析看不懂啊，pipeline, setting文件怎么用没说啊，但至少咱这个爬虫跑起来了不是，而且也抓到了一堆玩意儿是吧。所以今次就这么多，至于那些坑么，作者会在续集里填上的。最后惯例，诸君昌隆～<br><img src="https://cl.ly/3E1B0x3d1Q3L/comic_disaster_girl.jpg" alt=""></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2016/10/02/python-Scrapy-framework/">http://yoursite.com/2016/10/02/python-Scrapy-framework/</a></p>]]></content>
      
      <categories>
          
          <category> Scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Build Your Own Blog  - 被搜索引擎搜索到(Google)</title>
      <link href="/2016/09/25/hexo-Blog-SEO/"/>
      <url>/2016/09/25/hexo-Blog-SEO/</url>
      <content type="html"><![CDATA[<p>最近有小伙伴反映，啊那个兄台啊，你这个博客还算阔以，就是访问起来也忒麻烦了。百度和狗哥上找不捉，这个网址这么难记，小伙伴们不能日日瞻仰，很是为难呀。<br><strong><em>新任务获得：配置SEO</em></strong></p><a id="more"></a><h2 id="搜索引擎优化"><a href="#搜索引擎优化" class="headerlink" title="搜索引擎优化"></a>搜索引擎优化</h2><h3 id="修改公网网址"><a href="#修改公网网址" class="headerlink" title="修改公网网址"></a>修改公网网址</h3><p>这个其实还是属于前篇里说的基础键值配置，找到主工程目录里的 <code>_config.yml</code> 文件，然后修改</p><pre><code>url: https://millionaryearl.github.io（改成你的域名）</code></pre><p>至于域名购买么也简单得很，<a href="https://www.godaddy.com/" target="_blank" rel="noopener">狗爹</a> 或者 <a href="https://www.aliyun.com" target="_blank" rel="noopener">阿里云</a> 上买一个好了么</p><h2 id="提交狗哥"><a href="#提交狗哥" class="headerlink" title="提交狗哥"></a>提交狗哥</h2><h3 id="确认blog是否被收录。"><a href="#确认blog是否被收录。" class="headerlink" title="确认blog是否被收录。"></a>确认blog是否被收录。</h3><p>打开<a href="https://www.google.com" target="_blank" rel="noopener">狗哥搜索引擎</a>，输入 <code>site:yourwebaddress</code>. 要有结果么就继续，没有么就要去查查你的网站是否有部署问题了</p><h3 id="验证网站"><a href="#验证网站" class="headerlink" title="验证网站"></a>验证网站</h3><p>通过验证网站，可以证明你是该域名的拥有者，可以做为站长管理自己的网站－添加子节点啊，查流量啊，访问量啊什么的。<br>前往 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">狗哥站长</a> 登陆后开始验证。<br><img src="https://cl.ly/0o2L3j1u2O2E/hexo_4_verifyWebHost.png" alt=""></p><h3 id="选择验证方式"><a href="#选择验证方式" class="headerlink" title="选择验证方式"></a>选择验证方式</h3><p>验证方式有四种－ <strong><em>HTML标记</em></strong>，<strong><em>域名提供商</em></strong>， <strong><em>Google Analytics(分析)</em></strong> 和 <strong><em>Google 跟踪代码管理器</em></strong>。 这里我们使用第一种<br><img src="https://cl.ly/0n3I3h1F2a0k/hexo_4_2.png" alt=""></p><p>按照狗哥的要求，下载验证文件后，传到github里，再去浏览器里打开一下，那个验证按钮应该就亮了。都弄好之后，你就能看到自己的网站了<br><img src="https://cl.ly/0p0R2q3p3X3F/hexo_4_3.png" alt=""></p><h3 id="上传sitemap"><a href="#上传sitemap" class="headerlink" title="上传sitemap"></a>上传sitemap</h3><p>简单点说，sitemap文件就是你的站点地图，做为引索可以很方便的把你的网站内容的组织架构告知狗哥和其他搜索引擎。至于这个sitemap从哪里来么，我们需要</p><ol><li><p>安装插件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li><li><p>在 <strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  sitemap:</span><br><span class="line">path: sitemap.xml</span><br></pre></td></tr></table></figure></li><li><p>然后<code>hexo g</code>一下，你就能在工程主目录下看到 <code>sitemap.xml</code>文件了</p></li><li>最后回到狗哥站长的界面里，添加<code>sitemap.xml</code>的文件途径<br><img src="https://cl.ly/2y3G2X1h1N1B/hexo_4_4.png" alt=""></li></ol><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>至此我们的工作就算完成了，等待差不多一天之后，你就可以在狗哥搜索你的博客名了，基本上第一个就是你的博客站啦<br><img src="https://cl.ly/0q2S3d2a1P1K/hexo_4_5.png" alt=""></p><h2 id="提交百度"><a href="#提交百度" class="headerlink" title="提交百度"></a>提交百度</h2><p>这个因为github把百度爬虫给墙了，所以上面的路径对于百度走不通(会卡在网站验证那一步)。解决起来有点绕，核心思想是，通过cdn或者镜像托管，让百度爬虫可以抓取到我们的博客站。具体的实践攻略博主最近有点忙就先鸽了</p><h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>至此，我们的博客站主体配置工作就算告一段落了，剩下的活儿就写写博客了。所以hexo篇，至此暂时完结，感觉兴趣的伙计可以给我留言。诸君，武运昌隆！<br><img src="https://cl.ly/03081Q2b3D1L/comic_lol.gif" alt=""></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2016/09/25/hexo-Blog-SEO/">http://yoursite.com/2016/09/25/hexo-Blog-SEO/</a></p>]]></content>
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Build Your Own Blog  - 添加博客组件</title>
      <link href="/2016/09/18/hexo-Blog-method/"/>
      <url>/2016/09/18/hexo-Blog-method/</url>
      <content type="html"><![CDATA[<p>主题相关的界面工作完成之后，这个博客总算是有点样子。但是我看来看去，赶脚似乎大概眉笔好像有那么一点点简陋的哇。所以这一期我们打算看看有哪些附属功能可以加到博客上。<br><strong><em>新任务获得：美化个人网站-附属功能</em></strong> </p><a id="more"></a><h2 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h2><h3 id="评论模块"><a href="#评论模块" class="headerlink" title="评论模块"></a>评论模块</h3><p>有的theme可能带有评论，而有的没有。可选的插件有 <a href="https://disqus.com" target="_blank" rel="noopener"><strong><em>DISQUS</em></strong></a> （更简洁偏国外） 和 <a href="http://duoshuo.com" target="_blank" rel="noopener"><strong><em>多说</em></strong></a>（更社交偏国内）, 这里我们选用 <strong>DISQUS</strong></p><ol><li>在<strong>DISQUS</strong>上注册账号</li><li>在<strong>DISQUS</strong>上注册一个网站,得到网站的shortname</li><li>在工程目录里找到<code>_config.yml</code>，加入如下代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Disqus</span><br><span class="line">disqus_shortname: shortname</span><br></pre></td></tr></table></figure><ol start="4"><li>更多评论样式设置或者相关疑问，<a href="http://morris821028.github.io/2014/04/12/web/hexo-comment/" target="_blank" rel="noopener">正面上我</a></li></ol><h3 id="打赏模块"><a href="#打赏模块" class="headerlink" title="打赏模块"></a>打赏模块</h3><p>这个虽然说是正常人都不太会用的废物功能，但万一呢，是吧。万一又个慧眼独具，目光深邃的好汉看出来本人骨骼精奇，死乞白赖的非要给我打上呢是吧，所以本着用户至上的原则，咱还是加上这个模块吧</p><p>首先去看下<code>/themes/your_theme/layout/macro</code>途径下有没有 <code>reward.swig</code>文件，没有的话就新建，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.alipay or theme.wechatpay %&#125;</span><br><span class="line">  &lt;div style=&quot;padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; theme.reward_comment &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button id=&quot;rewardButton&quot; disable=&quot;enable&quot; onclick=&quot;var qr = document.getElementById(&apos;QR&apos;); if (qr.style.display === &apos;none&apos;) &#123;qr.style.display=&apos;block&apos;;&#125; else &#123;qr.style.display=&apos;none&apos;&#125;&quot;&gt;</span><br><span class="line">      &lt;span&gt;赏&lt;/span&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">    &lt;div id=&quot;QR&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">      &#123;% if theme.wechatpay %&#125;</span><br><span class="line">        &lt;div id=&quot;wechat&quot; style=&quot;display: inline-block&quot;&gt;</span><br><span class="line">          &lt;img id=&quot;wechat_qr&quot; src=&quot;&#123;&#123; theme.wechatpay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; WeChat Pay&quot;/&gt;</span><br><span class="line">          &lt;p&gt;微信打赏&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">      &#123;% if theme.alipay %&#125;</span><br><span class="line">        &lt;div id=&quot;alipay&quot; style=&quot;display: inline-block&quot;&gt;</span><br><span class="line">          &lt;img id=&quot;alipay_qr&quot; src=&quot;&#123;&#123; theme.alipay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Alipay&quot;/&gt;</span><br><span class="line">          &lt;p&gt;支付宝打赏&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>然后看下同路径下的<code>post.swig</code>文件, 确保在<code>&lt;footer class=&quot;post-footer&quot;&gt;</code>之前有这么一段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">     &#123;% include &apos;reward.swig&apos; %&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>再后去<strong>站点配置文件</strong><code>(工程主目录下的_config.yml)</code>，设置如下键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Donate 文章末尾显示打赏按钮</span><br><span class="line">reward_comment: 我知道是不会有人点的，但万一有人想不开呢？</span><br><span class="line">wechatpay: https://cl.ly/3W3I3O3t1622/wexinpay.JPG</span><br><span class="line">alipay: https://cl.ly/3t1O403j2P1F/alipay.JPG</span><br></pre></td></tr></table></figure><p>最后记得把那两个二维码的图片地址换成你自己的，不然就算你骨骼精奇，人也是把钱汇给我了。。。当然你要真倔强不换，我也是很欢迎滴。<br><img src="https://cl.ly/0a0n3y3t3136/comic_spiderman.jpg" alt=""></p><h3 id="RSS开启"><a href="#RSS开启" class="headerlink" title="RSS开启"></a>RSS开启</h3><p>这RSS开启了之后么，就可以方便别人订阅你的博客了，要装上也挺简单。先去命令行里主工程目录下运行</p><pre><code>$ npm install hexo-generator-feed --save</code></pre><p>然后去<strong>站点配置文件</strong><code>(工程主目录下的_config.yml)</code>里配置一下. P.S.似乎<code>Next</code>主题可以跳过这步，因为在<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里，已经设好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: 20</span><br></pre></td></tr></table></figure></p><h3 id="社交连接"><a href="#社交连接" class="headerlink" title="社交连接"></a>社交连接</h3><p>去到<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里，先找到<code>social</code>键，按如下格式添加键值对</p><pre><code>social_name: link_addresse.g.GitHub: https://github.com/MillionaryearlWeibo: http://weibo.com/2334525960/profile?topnav=1&amp;wvr=6&amp;is_all=1Personal: http://dukewei.typify.io</code></pre><p>然后去给对应的连接加上图标，这个图标和上篇里菜单项目图标一样，也是由 <a href="http://fontawesome.io" target="_blank" rel="noopener">Font Awesome</a> 提供的</p><pre><code>social_name: icon_name(e.g.)GitHub: githubTwitter: twitterWeibo: weiboPersonal: home</code></pre><h3 id="结尾样式-版权说明"><a href="#结尾样式-版权说明" class="headerlink" title="结尾样式-版权说明"></a>结尾样式-版权说明</h3><p>在主工程目录下，新建一个名为<code>scripts</code>的文件夹，在其中，新建一个AddTail.js脚本文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Filename: AddTail.js</span><br><span class="line"></span><br><span class="line">// Add a tail to every post from tail.md</span><br><span class="line">// Great for adding copyright info</span><br><span class="line"></span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">hexo.extend.filter.register(&apos;before_post_render&apos;, function(data)&#123;</span><br><span class="line">if(data.copyright == false) return data;</span><br><span class="line"></span><br><span class="line">// Add seperate line</span><br><span class="line">data.content += &apos;\n___\n&apos;;</span><br><span class="line"></span><br><span class="line">// Try to read tail.md</span><br><span class="line">try &#123;</span><br><span class="line">var file_content = fs.readFileSync(&apos;tail.md&apos;);</span><br><span class="line">if(file_content &amp;&amp; data.content.length &gt; 50) </span><br><span class="line">&#123;</span><br><span class="line">data.content += file_content;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">if (err.code !== &apos;ENOENT&apos;) throw err;</span><br><span class="line"></span><br><span class="line">// No process for ENOENT error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // 添加具体文章链接, 不需要去掉即可</span><br><span class="line">var permalink = &apos;\n本文链接：&apos; + data.permalink;</span><br><span class="line">data.content += permalink;</span><br><span class="line">  </span><br><span class="line">return data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后在工程主目录下新建一个<code>tail.md</code>文件，其中写上你的博客结尾内容，比如作者就写了下版权的破事儿</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>感觉用 <strong><em>NEXT</em></strong> 的博主特别多，所以咱要稍微搞些不一样的东西，比如换换背景什么的。<br>首先去<code>/themes/next/source/js/src</code>路径下新建你的样式文件，例如<code>particle.js</code></p><pre><code>!function(){function n(n,e,t){return n.getAttribute(e)||t}function e(n){return document.getElementsByTagName(n)}function t(){var t=e(&quot;script&quot;),o=t.length,i=t[o-1];return{l:o,z:n(i,&quot;zIndex&quot;,-1),o:n(i,&quot;opacity&quot;,.5),c:n(i,&quot;color&quot;,&quot;0,0,0&quot;),n:n(i,&quot;count&quot;,99)}}function o(){c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function i(){l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i){for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=&quot;rgba(&quot;+m.c+&quot;,&quot;+(t+.2)+&quot;)&quot;,l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)}),r(i)}var c,a,u=document.createElement(&quot;canvas&quot;),m=t(),d=&quot;c_n&quot;+m.l,l=u.getContext(&quot;2d&quot;),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n){window.setTimeout(n,1e3/45)},x=Math.random,w={x:null,y:null,max:2e4};u.id=d,u.style.cssText=&quot;position:fixed;top:0;left:0;z-index:&quot;+m.z+&quot;;opacity:&quot;+m.o,e(&quot;body&quot;)[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n){n=n||window.event,w.x=n.clientX,w.y=n.clientY},window.onmouseout=function(){w.x=null,w.y=null};for(var y=[],s=0;m.n&gt;s;s++){var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push({x:f,y:h,xa:g,ya:p,max:6e3})}setTimeout(function(){i()},100)}();</code></pre><p>然后在<code>/themes/next/layout</code>路径下的<code>_layout.swig</code>文件里，最后的<code>body</code>标签上，引用我们刚新建的js文件</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>至此基本上博客的功能就比较全了，其他的功能也还有很多，比如 PV啦，友链啦，搜索啦，笔者晚点会补上的。这期就先这样了，诸君，好运。<br><img src="https://cl.ly/1V0a2f2p0a1y/comic_dance.gif" alt=""></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2016/09/18/hexo-Blog-method/">http://yoursite.com/2016/09/18/hexo-Blog-method/</a></p>]]></content>
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Build Your Own Blog  - 更换主题相关样式</title>
      <link href="/2016/09/11/hexo-Blog-interface/"/>
      <url>/2016/09/11/hexo-Blog-interface/</url>
      <content type="html"><![CDATA[<p>有了基础的博客框架之后，我们就要去做一些个性化的设置了。毕竟同行千千万，内容取胜不太现实，所以咱就剑走偏锋把自己的博客给搞漂亮一些得了。<br><strong><em>新任务获得：美化个人网站-界面</em></strong> </p><a id="more"></a><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ol><li>在 <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">正面上我</a> 寻找喜欢的主题，这里我们使用 <a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">NEXT</a> 主题（活跃度最好，API也比较全，推荐一哈）</li><li>下载下来，保存到<code>主工程目录下 \themes</code>文件夹</li><li><p>在 <code>主工程目录下的_config.yml</code> 文件里修改 <code>themes</code> 键值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next //themes文件夹中对应文件夹的名称</span><br></pre></td></tr></table></figure></li></ol><h3 id="选定Scheme"><a href="#选定Scheme" class="headerlink" title="选定Scheme"></a>选定Scheme</h3><p>Scheme 是 NexT 提供的一种特性，简单点说呢就是这个主题可以通过改变 <code>Scheme</code> 的值来变成三种不同的布局：</p><ul><li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li><li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li><li>Pisces - 双栏 Scheme，小家碧玉似的清新</li></ul><p>在 <strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里修改 <code>scheme</code> 键值。</p><pre><code>#scheme: Muse#scheme: Mistscheme: Pisces</code></pre><h3 id="站点语言"><a href="#站点语言" class="headerlink" title="站点语言"></a>站点语言</h3><p>通过修改 <strong>站点配置文件</strong><code>(工程主目录下的_config.yml)</code>，将<code>language</code> 设置成所需的语言编码</p><pre><code>language: zh-Hans</code></pre><p>可选的语言编码如下表:</p><table><thead><tr><th>Language</th><th>Code</th></tr></thead><tbody><tr><td>English</td><td>en</td></tr><tr><td>简体中文</td><td>zh-Hans</td></tr><tr><td>Français</td><td>fr-FR</td></tr><tr><td>Português</td><td>pt</td></tr><tr><td>繁體中文</td><td>zh-hk 或者 zh-tw</td></tr><tr><td>Русский язык</td><td>ru</td></tr><tr><td>Deutsch</td><td>de</td></tr><tr><td>日本語</td><td>ja</td></tr><tr><td>Indonesian</td><td>id</td></tr></tbody></table><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><ol><li><p>设置菜单项目. 找到<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里<code>menu</code>字段，按照如下格式加入菜单项及其文件路径. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu_option : folder_directory</span><br><span class="line">(e.g.)</span><br><span class="line">categories : /categories</span><br></pre></td></tr></table></figure></li><li><p>设置菜单项目. 注意大部分菜单途径需要用户自己生成，在命令行工程主路径下，  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &quot;menu_option&quot;</span><br><span class="line">(e.g.)</span><br><span class="line">$ hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure></li><li><p>设置菜单项目. 然后编辑下 <code>/source/menu_option／index.md</code>， 大概弄成这样就成了,</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: menu_option</span><br><span class="line">date: 自动生成的</span><br><span class="line">type: &quot;menu_option&quot;</span><br><span class="line">comments: false (如果你加了评论的话)</span><br><span class="line">---</span><br><span class="line">e.g.</span><br><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2016-09-18 16:12:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>设置菜单项目名称. 找到<strong>主题对应语言文件</strong><code>(/themes/next/languages/your_language_name.yml)</code>里<code>menu</code>字段，按照如下格式加入菜单项名称,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu_option : menu_name</span><br><span class="line">(e.g.)</span><br><span class="line">categories: 分类</span><br></pre></td></tr></table></figure></li><li><p>设置菜单项目图标. 找到<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里<code>menu_icons</code>字段，按照如下格式加入菜单项图标名称。这里的图标名称都是由 <a href="http://fontawesome.io" target="_blank" rel="noopener">Font Awesome</a> 提供的,</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu_option : menu_icon_name</span><br><span class="line">(e.g.)</span><br><span class="line">categories: th</span><br></pre></td></tr></table></figure></li></ol><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><ol><li><p>找到<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>里<code>avatar</code>字段, 设置图片地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: /images/avatar.png</span><br></pre></td></tr></table></figure></li><li><p>把你的头像文件命名为 <code>avatar.png</code> 然后丢到 <code>(/themes/next/source/images)</code>文件夹里</p></li></ol><h3 id="颜色字体"><a href="#颜色字体" class="headerlink" title="颜色字体"></a>颜色字体</h3><p>这个其实算是最简单的差异化修改了，只要找到<code>/themes/next/source/css/variables/base.styl</code>文件里，把对应的颜色和字体改成自己想要的值就可以了，例如作者就修改了</p><pre><code>$black-light  = #336699$black-deep   = #660066</code></pre><h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>至此我们的博客站在界面布局方面就算是大功告成了，其实本期我们的主要工作就是把<strong>主题配置文件</strong><code>(/themes/next/_config.yml)</code>和 <strong>站点配置文件</strong><code>(工程主目录下的_config.yml)</code>的一些属性给配置起来，其他的很多配置工作都是通过修改其中对应的键值实现的，具体的键名解析请 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">正面上我</a>。 </p><p>欣赏一下，感悟一下，陶醉一下，然后分享给你的小伙伴们吧，一大波崇拜的目光即将到来，嘿嘿嘿。</p><p><img src="https://cl.ly/0k390e3v3z1v/comic_beautiful.jpg" alt=""></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2016/09/11/hexo-Blog-interface/">http://yoursite.com/2016/09/11/hexo-Blog-interface/</a></p>]]></content>
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Build Your Own Blog  - 建站并部署到Github</title>
      <link href="/2016/09/04/hexo-Blog-framework/"/>
      <url>/2016/09/04/hexo-Blog-framework/</url>
      <content type="html"><![CDATA[<p>一直打算搞一个自己的技术博客站，比起用什么简书啊，CSDN的第三方平台，直接高冷的丢出去一个自制的博客站，简直就是装比于无形，想想就带感好吧。<br><strong><em>新任务获得：部署个人网站</em></strong></p><a id="more"></a><p>嗯常规套路先看炼成书，查阅 《个人网站》 项：<br><code>公网域名 ＋ 服务器 ＋ 网站代码 ＝ 个人网站（常规合成法则）</code><br>呃，公网域名么 <a href="https://www.godaddy.com/" target="_blank" rel="noopener">狗爹</a> 上或许能找到便宜的。服务器，呃，<a href="https://aws.amazon.com" target="_blank" rel="noopener">AWS</a>好像有点贵，<a href="https://www.aliyun.com" target="_blank" rel="noopener">aliyun</a>凑合吧。网站代码，呃，不就是 <code>H5+CSS+JS/AJAX</code> 么，小意思。。。。。。个屁。哥是写Swift的，自己去搞这些web相关的，要搞死哥啊。再翻翻炼成书:<br><code>hexo（网站代码） + github（公共域名 &amp; 服务器） = 个人网站（黑暗合成法则）</code> </p><p><img src="https://cl.ly/022C2w20262o/commic_wow.jpg" alt=""></p><p><strong><em>任务更新：使用 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo</a> 和 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 制成个人博客。 </em></strong></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Step-1-开发环境"><a href="#Step-1-开发环境" class="headerlink" title="Step.1 开发环境"></a>Step.1 开发环境</h3><ol><li><strong>Node.js</strong>     <a href="https://nodejs.org/en/download/package-manager/#osx" target="_blank" rel="noopener">安装指南</a></li><li><strong>Git</strong>         <a href="https://git-scm.com/book/zh/v1/起步-安装-Git" target="_blank" rel="noopener">安装指南</a></li><li><p>运行如下命令不报错即配置成功。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure></li></ol><h3 id="Step-2-GitHub"><a href="#Step-2-GitHub" class="headerlink" title="Step.2 GitHub"></a>Step.2 GitHub</h3><ol><li>新建一个代码仓，命名为<code>yourname.github.io</code></li><li><p>开启 <strong>gh-pages</strong> 功能</p><ul><li>开启 Reposity <strong>Setting</strong> 页面如下</li><li>点击 <strong>Automatic page generator</strong></li></ul><p><img src="https://cl.ly/240P2i1D0b3j/hexo_1.png" alt=""></p></li><li><p>能够正常访问网址: <code>yourname.github.io</code> ，即配置成功。<strong><em>这个地址将成为你的博客网址（可以修改）</em></strong><br><img src="https://cl.ly/2L1R2X0e2j0U/comic_brilliant.jpg" alt=""></p></li></ol><h3 id="Step-3-Hexo"><a href="#Step-3-Hexo" class="headerlink" title="Step.3 Hexo"></a>Step.3 Hexo</h3><ol><li>新建一个工作目录，打开命令行并切换到新建的工作目录途径</li><li>安装 <strong>Hexo</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="Step-1-新建一个网站"><a href="#Step-1-新建一个网站" class="headerlink" title="Step.1 新建一个网站"></a>Step.1 新建一个网站</h3><ol><li>在命令行里执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></li></ol><h3 id="Step-2-本地测试"><a href="#Step-2-本地测试" class="headerlink" title="Step.2 本地测试"></a>Step.2 本地测试</h3><ol><li>在命令行里执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li></ol><p>如果能看到提示：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code>你就可以去浏览器里打开<code>http://localhost:4000/</code>，欣赏你的个人博客了</p><p><img src="https://cl.ly/1o0m2K121V18/hexo_2.png" alt=""></p><h3 id="Step-3-Github部署"><a href="#Step-3-Github部署" class="headerlink" title="Step.3 Github部署"></a>Step.3 Github部署</h3><ol><li><p>需要为自己配置身份信息，打开命令行，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure></li><li><p>去工程目录里找到 <code>_config.yml</code> 文件，修改下列属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>在命令行里执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li></ol><p>如果能看到提示 <code>INFO  Deploy done: git</code> 你就可以去浏览器里打开 <code>yourname.github.io</code>，继续欣赏你的个人博客了。</p><p><img src="https://cl.ly/441e3k3O1r2G/commic_yeah.jpg" alt=""></p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="Q1-命令行总是指令错误"><a href="#Q1-命令行总是指令错误" class="headerlink" title="Q1: 命令行总是指令错误"></a>Q1: 命令行总是指令错误</h3><ol><li><p>首先你的确保命令行的路径是你的工作目录（工程文件夹）的途径，在命令行里输入下列命令确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br></pre></td></tr></table></figure></li><li><p>其次确保 <code>node.js</code> &amp; <code>git</code> &amp; <code>hexo</code> 确实安装成功了，详见上述准备环节</p></li></ol><h3 id="Q2-Github部署时，总是提示-“Permission-Denied”"><a href="#Q2-Github部署时，总是提示-“Permission-Denied”" class="headerlink" title="Q2: Github部署时，总是提示 “Permission Denied”"></a>Q2: Github部署时，总是提示 “Permission Denied”</h3><p>这个是因为的Github的SSH连接授权有问题，需要确认本地机器上的ssh公钥与Github上的私钥是匹配的。如果实在无法确认的话，就直接去换套新的吧（作者就折腾了半天），<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="noopener">正面上我</a> 。</p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><ol><li><p>在命令行里执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></li><li><p>或者直接在工程目录的 <code>/source/_posts/</code> 下，新建 newblog.md 文件</p></li><li>编辑内容</li><li>在命令行里执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li></ol><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p><strong>Hexo</strong> 总体上来说还算是个挺不错的框架的，能玩的东西很多，插件，主题等等等等，想要学习更多的可以去 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官网</a>看看。</p><p>完结，撒花，鼓掌～～～</p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2016/09/04/hexo-Blog-framework/">http://yoursite.com/2016/09/04/hexo-Blog-framework/</a></p>]]></content>
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift Notes - 阿里云推送SDK配置</title>
      <link href="/2016/09/01/swift-APNS-aliyun/"/>
      <url>/2016/09/01/swift-APNS-aliyun/</url>
      <content type="html"><![CDATA[<p>新项目里的消息推送功能，公司技术部开会讨论后决定让 极光，百度，aws都歇菜，取而代之的是尝试 使用阿里云推送SDK。所以今天就简单记录下调试过程。<br><strong><em>新任务获得：使用阿里云推送SDK实现消息推送功能～</em></strong></p><a id="more"></a><p>嗯常规套路先看官方文档 <a href="https://help.aliyun.com/document_detail/30072.html?spm=5176.doc30071.6.156.YoX0P8" target="_blank" rel="noopener">正面上我</a> 。 嗯，很详细，很耐斯，很桥豆麻袋？库文件是OC写的？？？</p><p><img src="https://cl.ly/hRAS/ExcuseMe.jpeg" alt=""></p><p>坑爹啊，哥的项目都是swift写的啊。呃。。。。。。。。。好吧，也许加一个桥接就可以了。任务变更：桥接阿里云推送SDK（OC版）到Swift工程里，而后实现消息推送功能～</p><p><img src="https://cl.ly/hREs/challenge-accepted-meme.jpg" alt=""></p><h2 id="Ready-to-work"><a href="#Ready-to-work" class="headerlink" title="Ready to work"></a>Ready to work</h2><p>所谓工欲善其事，必先利其器。而且消息推送功能本身就是配置打过逻辑代码的功能，所以我们先要把准备工作做好。</p><hr><h3 id="Step-1-准备certificate文件"><a href="#Step-1-准备certificate文件" class="headerlink" title="Step.1 - 准备certificate文件"></a>Step.1 - 准备certificate文件</h3><p>由于消息推送功能的实现，涉及到Apple的官方资源（感兴趣的同志们可以自行去谷歌APNS），所以需要准备特别的证书文件：<strong><em>development certificate x1</em></strong>， <strong><em>distribution certificate x1</em></strong>。然后这两个文件具体怎么获得呢，请 <a href="https://help.aliyun.com/document_detail/30071.html?spm=5176.doc30072.6.155.ItR8Ib" target="_blank" rel="noopener">正面上我</a> 。</p><h3 id="Step-2-获得AppKey-AppSecret"><a href="#Step-2-获得AppKey-AppSecret" class="headerlink" title="Step.2 - 获得AppKey, AppSecret"></a>Step.2 - 获得AppKey, AppSecret</h3><p>这个appkey 和appsecret 是做啥的呢，嗯简单说就是这两个字串是阿里云用来标记你的app的，万一推错了就不好嘛，稍后我们会用点。那么问题又来了这两个字串那里搞呢？</p><p>支线任务获得：寻找NPC -公司的推送服务后台开发人员，交付 <strong><em>development certificate x1</em></strong>， <strong><em>distribution certificate x1</em></strong>后，获得 <strong><em>AppKey x1</em></strong>, <strong><em>AppSecret x1</em></strong>.</p><h3 id="Step-3-配置App"><a href="#Step-3-配置App" class="headerlink" title="Step.3 - 配置App"></a>Step.3 - 配置App</h3><p>配置App这个就简单了，打开你的项目代码。先把开发团队调到你们的公司</p><p><img src="https://cl.ly/hQyC/aliyun_1.jpeg" alt=""></p><p>然后打开 Post Notifications 功能</p><p><img src="https://cl.ly/hRCF/aliyun_2.png" alt=""></p><h3 id="Step-4-引入阿里云SDK"><a href="#Step-4-引入阿里云SDK" class="headerlink" title="Step.4 - 引入阿里云SDK"></a>Step.4 - 引入阿里云SDK</h3><p>下载好压缩包打开，获得四个库文件，然后全部拖到你的项目工程里去。再然后么把 build settings 里的 Enable Bitcode 给关了。最后再转到 Build Phases 里面的 Link Binary With libraries， 加入四个依赖的系统库: libz.tbd，libresolv.tbd，CoreTelephony.framework，SystemConfiguration.framework 。</p><hr><p>好啦，到此基本上所有的准备工作都做好了。接下来我们就可以开始写代码了。P.S. <del>其实上面的都可以在阿里云文档里看到，哥只是拿来凑字的</del>～～</p><h2 id="Core-Work"><a href="#Core-Work" class="headerlink" title="Core Work"></a>Core Work</h2><h3 id="Step-1-桥接"><a href="#Step-1-桥接" class="headerlink" title="Step.1 - 桥接"></a>Step.1 - 桥接</h3><p>先建立一个 Header File，命名为 YourProjectName-Bridging-Header.h 。 </p><p><img src="https://cl.ly/hRGV/aliyun_3.jpeg" alt=""></p><p>然后呢去到 Build Setting里，找到 Objective-C Bridging Header 填入刚才的文件名</p><p><img src="https://cl.ly/hRAR/aliyun_4.jpeg" alt=""></p><p>最后在刚才的桥接文件里，引入阿里云推送的库<code>#import &lt;CloudPushSDK/CloudPushSDK.h&gt;</code>, 这样就可以用SDK里的方法了。</p><h3 id="Step-2-配置推送"><a href="#Step-2-配置推送" class="headerlink" title="Step.2 - 配置推送"></a>Step.2 - 配置推送</h3><p>先在APP启动时调用配置方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let aliyunpush_AppKey = &quot;23448723&quot;</span><br><span class="line">let aliyunpush_AppSecret = &quot;8085ed1d1fc7739e9e058d2ad7fbb881&quot;</span><br><span class="line">let aliyunpush_messageNoti = &quot;CCPDidReceiveMessageNotification&quot;</span><br><span class="line"></span><br><span class="line">@UIApplicationMain</span><br><span class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</span><br><span class="line"></span><br><span class="line">    var window: UIWindow?</span><br><span class="line"></span><br><span class="line">    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool &#123;</span><br><span class="line">        // Override point for customization after application launch.</span><br><span class="line">        </span><br><span class="line">        //init aliyun Push SDK</span><br><span class="line">        initCloudPush(application: application)</span><br><span class="line">        </span><br><span class="line">        //feedback to aliyun server</span><br><span class="line">        CloudPushSDK.handleLaunching(launchOptions)</span><br><span class="line">        </span><br><span class="line">        return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>配置推送注册方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func initCloudPush(application : UIApplication) &#123;</span><br><span class="line"></span><br><span class="line">        CloudPushSDK.asyncInit(aliyunpush_AppKey, appSecret: aliyunpush_AppSecret) &#123; (res) in</span><br><span class="line">            if (res?.success)! &#123;</span><br><span class="line">                print(&quot;Push SDK init success, deviceID: \(CloudPushSDK.getDeviceId())&quot;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                print(&quot;Push SDK init failed, error: \(res?.error?.localizedDescription)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //register APNS to fetch deviceToken</span><br><span class="line">        let settings = UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)</span><br><span class="line"></span><br><span class="line">        if #available(iOS 8.0, *) &#123;</span><br><span class="line">            </span><br><span class="line">            //iOS 8 notifications</span><br><span class="line">            </span><br><span class="line">            application.registerUserNotificationSettings(settings)</span><br><span class="line">            application.registerForRemoteNotifications()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            </span><br><span class="line">            //iOS &lt; 8 Notifications</span><br><span class="line">            UIApplication.shared.registerUserNotificationSettings(settings)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        registerMessageReceive()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //APNS register success</span><br><span class="line">    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) &#123;</span><br><span class="line">        CloudPushSDK.registerDevice(deviceToken as Data!) &#123; (res) in</span><br><span class="line">            if (res?.success)!&#123;</span><br><span class="line">                print(&quot;Register deviceToken success&quot;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                print(&quot;Register deviceToken failed, error:\(res?.error?.localizedDescription)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //APNS register failed</span><br><span class="line">    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) &#123;</span><br><span class="line">        print(&quot;did fail to register for remote notification with error : \(error.localizedDescription)&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>推送处理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//Observer remote Notifications - Background Mode &amp; Inactive Mode</span><br><span class="line">   func registerMessageReceive()   &#123;</span><br><span class="line">       NotificationCenter.default.addObserver(self, selector: Selector((&quot;onMessageReceived&quot;)), name: NSNotification.Name(rawValue: aliyunpush_messageNoti), object: nil)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //Handle remote Notifications - Background Mode &amp; Inactive Mode</span><br><span class="line">   func onMessageReceived(notification: NSNotification)  &#123;</span><br><span class="line">       let message : CCPSysMessage = notification.object as! CCPSysMessage</span><br><span class="line">       let title : NSString = NSString(data: message.title, encoding: String.Encoding.utf8.rawValue)!</span><br><span class="line">       let body : NSString = NSString(data: message.title, encoding: String.Encoding.utf8.rawValue)!</span><br><span class="line">       print(&quot;Received Message title: \(title), content:\(body)&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //Observer &amp; Handle remote Notifications - Foreground Mode</span><br><span class="line">   func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) &#123;</span><br><span class="line">       print(&quot;REceive one notification.&quot;)</span><br><span class="line">       </span><br><span class="line">       //retreive APNS content</span><br><span class="line">       </span><br><span class="line">       let aps_dic : NSDictionary = userInfo[&quot;aps&quot;] as! NSDictionary</span><br><span class="line">       </span><br><span class="line">       //content</span><br><span class="line">       let content = aps_dic.value(forKey: &quot;alert&quot;)</span><br><span class="line">       </span><br><span class="line">       //barge num</span><br><span class="line">       let badge = (aps_dic.value(forKey: &quot;badge&quot;) as AnyObject).integerValue</span><br><span class="line">       </span><br><span class="line">       //sound</span><br><span class="line">       let sound = aps_dic.value(forKey: &quot;sound&quot;)</span><br><span class="line">       </span><br><span class="line">       //extras</span><br><span class="line">       let extras = aps_dic.value(forKey: &quot;Extras&quot;)</span><br><span class="line">       </span><br><span class="line">       print(&quot;content: \(content)\n, badge:\(badge)\n, sound :\(sound)\n, Extras: \(extras)&quot;)</span><br><span class="line">       </span><br><span class="line">       application.applicationIconBadgeNumber = 0</span><br><span class="line">       </span><br><span class="line">       CloudPushSDK.handleReceiveRemoteNotification(userInfo)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后运行程序，看到如下结果就可以去交任务啦。</p><p><img src="https://cl.ly/hQrt/aliyun_8.png" alt=""></p><p>完结，鼓掌，撒花～～</p><p><img src="https://cl.ly/hQsX/PrettyGood.png" alt=""></p><hr><p>This artical is avaliable under WTFPL-V2. Generally, everyone is permitted to copy and do what the fuck you want to.<br>P.S. Even so said, your kindly declaration that inspired from this site - Chen’s Alchemy would be appreciated</p><p>本文链接：<a href="http://yoursite.com/2016/09/01/swift-APNS-aliyun/">http://yoursite.com/2016/09/01/swift-APNS-aliyun/</a></p>]]></content>
      
      <categories>
          
          <category> APNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
